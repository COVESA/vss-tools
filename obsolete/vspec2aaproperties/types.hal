/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package android.hardware.automotive.vehicle@2.0;
/**
 * Enumerates supported data type for VehicleProperty.
 *
 * Used to create property ID in VehicleProperty enum.
 */
enum VehiclePropertyType : int32_t {
    STRING          = 0x00100000,
    BOOLEAN         = 0x00200000,
    INT32           = 0x00400000,
    INT32_VEC       = 0x00410000,
    INT64           = 0x00500000,
    INT64_VEC       = 0x00510000,
    FLOAT           = 0x00600000,
    FLOAT_VEC       = 0x00610000,
    BYTES           = 0x00700000,
    /**
     * Any combination of scalar or vector types. The exact format must be
     * provided in the description of the property.
     *
     * For vendor MIXED type properties, configArray needs to be formatted in this
     * structure.
     * configArray[0], 1 indicates the property has a String value
     * configArray[1], 1 indicates the property has a Boolean value .
     * configArray[2], 1 indicates the property has an Integer value.
     * configArray[3], the number indicates the size of Integer[] in the property.
     * configArray[4], 1 indicates the property has a Long value.
     * configArray[5], the number indicates the size of Long[] in the property.
     * configArray[6], 1 indicates the property has a Float value.
     * configArray[7], the number indicates the size of Float[] in the property.
     * configArray[8], the number indicates the size of byte[] in the property.
     * For example:
     * {@code configArray = {1, 1, 1, 3, 0, 0, 0, 0, 0}} indicates the property has
     * a String value, a Boolean value, an Integer value and an array with 3 integers.
     */
    MIXED           = 0x00e00000,
    MASK            = 0x00ff0000
};
/**
 * Vehicle Areas
 * Used to construct property IDs in the VehicleProperty enum.
 *
 * Some properties may be associated with particular vehicle areas. For
 * example, VehicleProperty:DOOR_LOCK property must be associated with
 * particular door, thus this property must be marked with
 * VehicleArea:DOOR flag.
 *
 * Other properties may not be associated with particular vehicle area.
 * These kinds of properties must have VehicleArea:GLOBAL flag.
 *
 * [Definition] Area: An area represents a unique element of an AreaType.
 *   For instance, if AreaType is WINDOW, then an area may be FRONT_WINDSHIELD.
 *
 * [Definition] AreaID: An AreaID is a combination of one or more areas,
 *   and is represented using a bitmask of Area enums. Different AreaTypes may
 *   not be mixed in a single AreaID. For instance, a window area cannot be
 *   combined with a seat area in an AreaID.
 *
 * Rules for mapping a zoned property to AreaIDs:
 *  - A property must be mapped to an array of AreaIDs that are impacted when
 *    the property value changes.
 *  - Each element in the array must represent an AreaID, in which the
 *    property value can only be changed together in all the areas within
 *    the AreaID and never independently. That is, when the property value
 *    changes in one of the areas in an AreaID in the array, then it must
 *    automatically change in all other areas in the AreaID.
 *  - The property value must be independently controllable in any two
 *    different AreaIDs in the array.
 *  - An area must only appear once in the array of AreaIDs. That is, an
 *    area must only be part of a single AreaID in the array.
 *
 * [Definition] Global Property: A property that applies to the entire car
 *   and is not associated with a specific area. For example, FUEL_LEVEL,
 *   HVAC_STEERING_WHEEL_HEAT.
 *
 * Rules for mapping a global property to AreaIDs:
 *  - A global property must not be mapped to AreaIDs.
*/
enum VehicleArea : int32_t {
    GLOBAL      = 0x01000000,
    /** WINDOW maps to enum VehicleAreaWindow */
    WINDOW      = 0x03000000,
    /** MIRROR maps to enum VehicleAreaMirror */
    MIRROR      = 0x04000000,
    /** SEAT maps to enum VehicleAreaSeat */
    SEAT        = 0x05000000,
    /** DOOR maps to enum VehicleAreaDoor */
    DOOR        = 0x06000000,
    /** WHEEL maps to enum VehicleAreaWheel */
    WHEEL       = 0x07000000,
    MASK        = 0x0f000000,
};
/**
 * Enumerates property groups.
 *
 * Used to create property ID in VehicleProperty enum.
 */
enum VehiclePropertyGroup : int32_t {
    /**
     * Properties declared in AOSP must use this flag.
     */
    SYSTEM      = 0x10000000,
    /**
     * Properties declared by vendors must use this flag.
     */
    VENDOR      = 0x20000000,
    MASK        = 0xf0000000,
};
/**
 * Declares all vehicle properties. VehicleProperty has a bitwise structure.
 * Each property must have:
 *  - a unique id from range 0x0100 - 0xffff
 *  - associated data type using VehiclePropertyType
 *  - property group (VehiclePropertyGroup)
 *  - vehicle area (VehicleArea)
 *
 * Vendors are allowed to extend this enum with their own properties. In this
 * case they must use VehiclePropertyGroup:VENDOR flag when the property is
 * declared.
 *
 * When a property's status field is not set to AVAILABLE:
 *  - IVehicle#set may return StatusCode::NOT_AVAILABLE.
 *  - IVehicle#get is not guaranteed to work.
 *
 * Properties set to values out of range must be ignored and no action taken
 * in response to such ill formed requests.
 */
enum VehicleProperty : int32_t {
    /** Undefined property. */
    INVALID = 0x00000000,
    /**
     * VIN of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_VIN = (
        0x0100
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),
    /**
     * Manufacturer of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_MAKE = (
        0x0101
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),
    /**
     * Model of vehicle
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    INFO_MODEL = (
        0x0102
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),
    /**
     * Model year of vehicle.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:YEAR
     */
    INFO_MODEL_YEAR = (
        0x0103
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Fuel capacity of the vehicle in milliliters
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:MILLILITER
     */
    INFO_FUEL_CAPACITY = (
        0x0104
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * List of fuels the vehicle may use
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @data_enum FuelType
     */
    INFO_FUEL_TYPE = (
        0x0105
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),
    /**
     * Battery capacity of the vehicle, if EV or hybrid.  This is the nominal
     * battery capacity when the vehicle is new.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:WH
     */
    INFO_EV_BATTERY_CAPACITY = (
        0x0106
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * List of connectors this EV may use
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @data_enum EvConnectorType
     * @access VehiclePropertyAccess:READ
     */
    INFO_EV_CONNECTOR_TYPE = (
        0x0107
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),
    /**
     * Fuel door location
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @data_enum PortLocationType
     * @access VehiclePropertyAccess:READ
     */
    INFO_FUEL_DOOR_LOCATION = (
        0x0108
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * EV port location
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @data_enum PortLocationType
     */
    INFO_EV_PORT_LOCATION = (
        0x0109
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Driver's seat location
     * VHAL implementations must ignore the areaId. Use VehicleArea:GLOBAL.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @data_enum VehicleAreaSeat
     * @access VehiclePropertyAccess:READ
     */
    INFO_DRIVER_SEAT = (
        0x010A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Exterior dimensions of vehicle.
     *
     *  int32Values[0] = height
     *  int32Values[1] = length
     *  int32Values[2] = width
     *  int32Values[3] = width including mirrors
     *  int32Values[4] = wheel base
     *  int32Values[5] = track width front
     *  int32Values[6] = track width rear
     *  int32Values[7] = curb to curb turning radius
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:MILLIMETER
     */
    INFO_EXTERIOR_DIMENSIONS = (
        0x010B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),
    /**
     * Multiple EV port locations
     *
     * Implement this property if the vehicle has multiple EV ports.
     * Port locations are defined in PortLocationType.
     * For example, a car has one port in front left and one port in rear left:
     *   int32Values[0] = PortLocationType::FRONT_LEFT
     *   int32Values[0] = PortLocationType::REAR_LEFT
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @data_enum PortLocationType
     */
    INFO_MULTI_EV_PORT_LOCATIONS = (
        0x010C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),
    /**
     * Current odometer value of the vehicle
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:KILOMETER
     */
    PERF_ODOMETER = (
        0x0204
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Speed of the vehicle
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:METER_PER_SEC
     */
    PERF_VEHICLE_SPEED = (
        0x0207
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Speed of the vehicle for displays
     *
     * Some cars display a slightly slower speed than the actual speed.  This is
     * usually displayed on the speedometer.
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:METER_PER_SEC
     */
    PERF_VEHICLE_SPEED_DISPLAY = (
        0x0208
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Front bicycle model steering angle for vehicle
     *
     * Angle is in degrees.  Left is negative.
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:DEGREES
     */
    PERF_STEERING_ANGLE = (
        0x0209
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Rear bicycle model steering angle for vehicle
     *
     * Angle is in degrees.  Left is negative.
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:DEGREES
     */
    PERF_REAR_STEERING_ANGLE = (
        0x0210
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Temperature of engine coolant
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENGINE_COOLANT_TEMP = (
        0x0301
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Engine oil level
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleOilLevel
     */
    ENGINE_OIL_LEVEL = (
        0x0303
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Temperature of engine oil
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENGINE_OIL_TEMP = (
        0x0304
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Engine rpm
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:RPM
     */
    ENGINE_RPM = (
        0x0305
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Reports wheel ticks
     *
     * The first element in the vector is a reset count.  A reset indicates
     * previous tick counts are not comparable with this and future ones.  Some
     * sort of discontinuity in tick counting has occurred.
     *
     * The next four elements represent ticks for individual wheels in the
     * following order: front left, front right, rear right, rear left.  All
     * tick counts are cumulative.  Tick counts increment when the vehicle
     * moves forward, and decrement when vehicles moves in reverse.  The ticks
     * should be reset to 0 when the vehicle is started by the user.
     *
     *  int64Values[0] = reset count
     *  int64Values[1] = front left ticks
     *  int64Values[2] = front right ticks
     *  int64Values[3] = rear right ticks
     *  int64Values[4] = rear left ticks
     *
     * configArray is used to indicate the micrometers-per-wheel-tick value and
     * which wheels are supported.  configArray is set as follows:
     *
     *  configArray[0], bits [0:3] = supported wheels.  Uses enum Wheel.
     *  configArray[1] = micrometers per front left wheel tick
     *  configArray[2] = micrometers per front right wheel tick
     *  configArray[3] = micrometers per rear right wheel tick
     *  configArray[4] = micrometers per rear left wheel tick
     *
     * NOTE:  If a wheel is not supported, its value shall always be set to 0.
     *
     * VehiclePropValue.timestamp must be correctly filled in.
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     */
    WHEEL_TICK = (
        0x0306
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT64_VEC
        | VehicleArea:GLOBAL),
    /**
     * Fuel remaining in the the vehicle, in milliliters
     *
     * Value may not exceed INFO_FUEL_CAPACITY
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:MILLILITER
     */
    FUEL_LEVEL = (
        0x0307
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Fuel door open
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    FUEL_DOOR_OPEN = (
        0x0308
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * EV battery level in WH, if EV or hybrid
     *
     * Value may not exceed INFO_EV_BATTERY_CAPACITY
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:WH
     */
    EV_BATTERY_LEVEL = (
        0x0309
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * EV charge port open
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    EV_CHARGE_PORT_OPEN = (
        0x030A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * EV charge port connected
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    EV_CHARGE_PORT_CONNECTED = (
        0x030B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * EV instantaneous charge rate in milliwatts
     *
     * Positive value indicates battery is being charged.
     * Negative value indicates battery being discharged.
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:MW
     */
    EV_BATTERY_INSTANTANEOUS_CHARGE_RATE = (
        0x030C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Range remaining
     *
     * Meters remaining of fuel and charge.  Range remaining shall account for
     * all energy sources in a vehicle.  For example, a hybrid car's range will
     * be the sum of the ranges based on fuel and battery.
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ_WRITE
     * @unit VehicleUnit:METER
     */
    RANGE_REMAINING = (
        0x0308
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Tire pressure
     *
     * Each tires is identified by its areaConfig.areaId config and their
     * minFloatValue/maxFloatValue are used to store OEM recommended pressure
     * range.
     * The Min value in the areaConfig data represents the lower bound of
     * the recommended tire pressure.
     * The Max value in the areaConfig data represents the upper bound of
     * the recommended tire pressure.
     * For example:
     * The following areaConfig indicates the recommended tire pressure
     * of left_front tire is from 200.0 KILOPASCAL to 240.0 KILOPASCAL.
     * .areaConfigs = {
     *      VehicleAreaConfig {
     *          .areaId = VehicleAreaWheel::LEFT_FRONT,
     *          .minFloatValue = 200.0,
     *          .maxFloatValue = 240.0,
     *      }
     * },
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:KILOPASCAL
     */
    TIRE_PRESSURE = (
        0x0309
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:WHEEL),
    /**
     * Currently selected gear
     *
     * This is the gear selected by the user.
     *
     * Values in the config data must represent the list of supported gears
     * for this vehicle.  For example, config data for an automatic transmission
     * must contain {GEAR_NEUTRAL, GEAR_REVERSE, GEAR_PARK, GEAR_DRIVE,
     * GEAR_1, GEAR_2,...} and for manual transmission the list must be
     * {GEAR_NEUTRAL, GEAR_REVERSE, GEAR_1, GEAR_2,...}
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleGear
     */
    GEAR_SELECTION = (
        0x0400
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Current gear. In non-manual case, selected gear may not
     * match the current gear. For example, if the selected gear is GEAR_DRIVE,
     * the current gear will be one of GEAR_1, GEAR_2 etc, which reflects
     * the actual gear the transmission is currently running in.
     *
     * Values in the config data must represent the list of supported gears
     * for this vehicle.  For example, config data for an automatic transmission
     * must contain {GEAR_NEUTRAL, GEAR_REVERSE, GEAR_PARK, GEAR_1, GEAR_2,...}
     * and for manual transmission the list must be
     * {GEAR_NEUTRAL, GEAR_REVERSE, GEAR_1, GEAR_2,...}. This list need not be the
     * same as that of the supported gears reported in GEAR_SELECTION.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleGear
     */
    CURRENT_GEAR = (
        0x0401
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Parking brake state.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    PARKING_BRAKE_ON = (
        0x0402
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * Auto-apply parking brake.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    PARKING_BRAKE_AUTO_APPLY = (
        0x0403
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * Warning for fuel low level.
     *
     * This property corresponds to the low fuel warning on the dashboard.
     * Once FUEL_LEVEL_LOW is set, it should not be cleared until more fuel is
     * added to the vehicle.  This property may take into account all fuel
     * sources for a vehicle - for example:
     *
     *   For a gas powered vehicle, this property is based soley on gas level.
     *   For a battery powered vehicle, this property is based solely on battery level.
     *   For a hybrid vehicle, this property may be based on the combination of gas and battery
     *      levels, at the OEM's discretion.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    FUEL_LEVEL_LOW = (
        0x0405
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * Night mode
     *
     * True indicates that the night mode sensor has detected that the car cabin environment has
     * low light. The platform could use this, for example, to enable appropriate UI for
     * better viewing in dark or low light environments.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    NIGHT_MODE = (
        0x0407
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * State of the vehicles turn signals
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleTurnSignal
     */
    TURN_SIGNAL_STATE = (
        0x0408
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Represents ignition state
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleIgnitionState
     */
    IGNITION_STATE = (
        0x0409
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * ABS is active
     *
     * Set to true when ABS is active.  Reset to false when ABS is off.  This
     * property may be intermittently set (pulsing) based on the real-time
     * state of the ABS system.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    ABS_ACTIVE = (
        0x040A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * Traction Control is active
     *
     * Set to true when traction control (TC) is active.  Reset to false when
     * TC is off.  This property may be intermittently set (pulsing) based on
     * the real-time state of the TC system.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    TRACTION_CONTROL_ACTIVE = (
        0x040B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /*
     * HVAC Properties
     *
     * Additional rules for mapping a zoned HVAC property (except
     * HVAC_MAX_DEFROST_ON) to AreaIDs:
     *  - Every seat in VehicleAreaSeat that is available in the car, must be
     *    part of an AreaID in the AreaID array.
     *
     * Example 1: A car has two front seats (ROW_1_LEFT, ROW_1_RIGHT) and three
     *  back seats (ROW_2_LEFT, ROW_2_CENTER, ROW_2_RIGHT). There are two
     *  temperature control units -- driver side and passenger side.
     *   - A valid mapping set of AreaIDs for HVAC_TEMPERATURE_SET would be a
     *     two element array:
     *      - ROW_1_LEFT  | ROW_2_LEFT
     *      - ROW_1_RIGHT | ROW_2_CENTER | ROW_2_RIGHT
     *   - An alternative mapping for the same hardware configuration would be:
     *      - ROW_1_LEFT  | ROW_2_CENTER | ROW_2_LEFT
     *      - ROW_1_RIGHT | ROW_2_RIGHT
     *  The temperature controllers are assigned to the seats which they
     *  "most influence", but every seat must be included exactly once. The
     *  assignment of the center rear seat to the left or right AreaID may seem
     *  arbitrary, but the inclusion of every seat in exactly one AreaID ensures
     *  that the seats in the car are all expressed and that a "reasonable" way
     *  to affect each seat is available.
     *
     * Example 2: A car has three seat rows with two seats in the front row (ROW_1_LEFT,
     *  ROW_1_RIGHT) and three seats in the second (ROW_2_LEFT, ROW_2_CENTER,
     *  ROW_2_RIGHT) and third rows (ROW_3_LEFT, ROW_3_CENTER, ROW_3_RIGHT). There
     *  are three temperature control units -- driver side, passenger side, and rear.
     *   - A reasonable way to map HVAC_TEMPERATURE_SET to AreaIDs is a three
     *     element array:
     *     - ROW_1_LEFT
     *     - ROW_1_RIGHT
     *     - ROW_2_LEFT | ROW_2_CENTER | ROW_2_RIGHT | ROW_3_LEFT | ROW_3_CENTER | ROW_3_RIGHT
     */
    /**
     * Fan speed setting
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_FAN_SPEED = (
        0x0500
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Fan direction setting
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleHvacFanDirection
     */
    HVAC_FAN_DIRECTION = (
        0x0501
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * HVAC current temperature.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    HVAC_TEMPERATURE_CURRENT = (
        0x0502
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:SEAT),
    /**
     * HVAC, target temperature set.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @unit VehicleUnit:CELSIUS
     */
    HVAC_TEMPERATURE_SET = (
        0x0503
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:SEAT),
    /**
     * Fan-based defrost for designated window.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_DEFROSTER = (
        0x0504
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:WINDOW),
    /**
     * On/off AC for designated areaId
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @config_flags Supported areaIds
     */
    HVAC_AC_ON = (
        0x0505
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),
    /**
     * On/off max AC
     *
     * When MAX AC is on, the ECU may adjust the vent position, fan speed,
     * temperature, etc as necessary to cool the vehicle as quickly as possible.
     * Any parameters modified as a side effect of turning on/off the MAX AC
     * parameter shall generate onPropertyEvent() callbacks to the VHAL.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_MAX_AC_ON = (
        0x0506
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),
    /**
     * On/off max defrost
     *
     * When MAX DEFROST is on, the ECU may adjust the vent position, fan speed,
     * temperature, etc as necessary to defrost the windows as quickly as
     * possible.  Any parameters modified as a side effect of turning on/off
     * the MAX DEFROST parameter shall generate onPropertyEvent() callbacks to
     * the VHAL.
     * The AreaIDs for HVAC_MAX_DEFROST_ON indicate MAX DEFROST can be controlled
     * in the area.
     * For example:
     * areaConfig.areaId = {ROW_1_LEFT | ROW_1_RIGHT} indicates HVAC_MAX_DEFROST_ON
     * only can be controlled for the front rows.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_MAX_DEFROST_ON = (
        0x0507
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),
    /**
     * Recirculation on/off
     *
     * Controls the supply of exterior air to the cabin.  Recirc “on” means the
     * majority of the airflow into the cabin is originating in the cabin.
     * Recirc “off” means the majority of the airflow into the cabin is coming
     * from outside the car.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_RECIRC_ON = (
        0x0508
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),
    /**
     * Enable temperature coupling between areas.
     *
     * The AreaIDs for HVAC_DUAL_ON property shall contain a combination of
     * HVAC_TEMPERATURE_SET AreaIDs that can be coupled together. If
     * HVAC_TEMPERATURE_SET is mapped to AreaIDs [a_1, a_2, ..., a_n], and if
     * HVAC_DUAL_ON can be enabled to couple a_i and a_j, then HVAC_DUAL_ON
     * property must be mapped to [a_i | a_j]. Further, if a_k and a_l can also
     * be coupled together separately then HVAC_DUAL_ON must be mapped to
     * [a_i | a_j, a_k | a_l].
     *
     * Example: A car has two front seats (ROW_1_LEFT, ROW_1_RIGHT) and three
     *  back seats (ROW_2_LEFT, ROW_2_CENTER, ROW_2_RIGHT). There are two
     *  temperature control units -- driver side and passenger side -- which can
     *  be optionally synchronized. This may be expressed in the AreaIDs this way:
     *  - HVAC_TEMPERATURE_SET->[ROW_1_LEFT | ROW_2_LEFT, ROW_1_RIGHT | ROW_2_CENTER | ROW_2_RIGHT]
     *  - HVAC_DUAL_ON->[ROW_1_LEFT | ROW_2_LEFT | ROW_1_RIGHT | ROW_2_CENTER | ROW_2_RIGHT]
     *
     * When the property is enabled, the ECU must synchronize the temperature
     * for the affected areas. Any parameters modified as a side effect
     * of turning on/off the DUAL_ON parameter shall generate
     * onPropertyEvent() callbacks to the VHAL. In addition, if setting
     * a temperature (i.e. driver's temperature) changes another temperature
     * (i.e. front passenger's temperature), then the appropriate
     * onPropertyEvent() callbacks must be generated.  If a user changes a
     * temperature that breaks the coupling (e.g. setting the passenger
     * temperature independently) then the VHAL must send the appropriate
     * onPropertyEvent() callbacks (i.e. HVAC_DUAL_ON = false,
     * HVAC_TEMPERATURE_SET[AreaID] = xxx, etc).
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_DUAL_ON = (
        0x0509
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),
    /**
     * On/off automatic mode
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_AUTO_ON = (
        0x050A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),
    /**
     * Seat heating/cooling
     *
     * Negative values indicate cooling.
     * 0 indicates off.
     * Positive values indicate heating.
     *
     * Some vehicles may have multiple levels of heating and cooling. The
     * min/max range defines the allowable range and number of steps in each
     * direction.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_SEAT_TEMPERATURE = (
        0x050B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Side Mirror Heat
     *
     * Increasing values denote higher heating levels for side mirrors.
     * The Max value in the config data represents the highest heating level.
     * The Min value in the config data MUST be zero and indicates no heating.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_SIDE_MIRROR_HEAT = (
        0x050C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),
    /**
     * Steering Wheel Heating/Cooling
     *
     * Sets the amount of heating/cooling for the steering wheel
     * config data Min and Max MUST be set appropriately.
     * Positive value indicates heating.
     * Negative value indicates cooling.
     * 0 indicates temperature control is off.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_STEERING_WHEEL_HEAT = (
        0x050D
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Temperature units for display
     *
     * Indicates whether the vehicle is displaying temperature to the user as
     * Celsius or Fahrenheit.
     * VehiclePropConfig.configArray is used to indicate the supported temperature display units.
     * For example: configArray[0] = CELSIUS
     *              configArray[1] = FAHRENHEIT
     *
     * This parameter MAY be used for displaying any HVAC temperature in the system.
     * Values must be one of VehicleUnit::CELSIUS or VehicleUnit::FAHRENHEIT
     * Note that internally, all temperatures are represented in floating point Celsius.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleUnit
     */
    HVAC_TEMPERATURE_DISPLAY_UNITS = (
        0x050E
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Actual fan speed
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    HVAC_ACTUAL_FAN_SPEED_RPM = (
        0x050F
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Represents global power state for HVAC. Setting this property to false
     * MAY mark some properties that control individual HVAC features/subsystems
     * to UNAVAILABLE state. Setting this property to true MAY mark some
     * properties that control individual HVAC features/subsystems to AVAILABLE
     * state (unless any/all of them are UNAVAILABLE on their own individual
     * merits).
     *
     * [Definition] HvacPower_DependentProperties: Properties that need HVAC to be
     *   powered on in order to enable their functionality. For example, in some cars,
     *   in order to turn on the AC, HVAC must be powered on first.
     *
     * HvacPower_DependentProperties list must be set in the
     * VehiclePropConfig.configArray. HvacPower_DependentProperties must only contain
     * properties that are associated with VehicleArea:SEAT. Properties that are not
     * associated with VehicleArea:SEAT, for example, HVAC_DEFROSTER, must never
     * depend on HVAC_POWER_ON property and must never be part of
     * HvacPower_DependentProperties list.
     *
     * AreaID mapping for HVAC_POWER_ON property must contain all AreaIDs that
     * HvacPower_DependentProperties are mapped to.
     *
     * Example 1: A car has two front seats (ROW_1_LEFT, ROW_1_RIGHT) and three back
     *  seats (ROW_2_LEFT, ROW_2_CENTER, ROW_2_RIGHT). If the HVAC features (AC,
     *  Temperature etc.) throughout the car are dependent on a single HVAC power
     *  controller then HVAC_POWER_ON must be mapped to
     *  [ROW_1_LEFT | ROW_1_RIGHT | ROW_2_LEFT | ROW_2_CENTER | ROW_2_RIGHT].
     *
     * Example 2: A car has two seats in the front row (ROW_1_LEFT, ROW_1_RIGHT) and
     *   three seats in the second (ROW_2_LEFT, ROW_2_CENTER, ROW_2_RIGHT) and third
     *   rows (ROW_3_LEFT, ROW_3_CENTER, ROW_3_RIGHT). If the car has temperature
     *   controllers in the front row which can operate entirely independently of
     *   temperature controllers in the back of the vehicle, then HVAC_POWER_ON
     *   must be mapped to a two element array:
     *   - ROW_1_LEFT | ROW_1_RIGHT
     *   - ROW_2_LEFT | ROW_2_CENTER | ROW_2_RIGHT | ROW_3_LEFT | ROW_3_CENTER | ROW_3_RIGHT
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_POWER_ON = (
        0x0510
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),
    /**
     * Fan Positions Available
     *
     * This is a bit mask of fan positions available for the zone.  Each
     * available fan direction is denoted by a separate entry in the vector.  A
     * fan direction may have multiple bits from vehicle_hvac_fan_direction set.
     * For instance, a typical car may have the following fan positions:
     *   - FAN_DIRECTION_FACE (0x1)
     *   - FAN_DIRECTION_FLOOR (0x2)
     *   - FAN_DIRECTION_FACE | FAN_DIRECTION_FLOOR (0x3)
     *   - FAN_DIRECTION_DEFROST (0x4)
     *   - FAN_DIRECTION_FLOOR | FAN_DIRECTION_DEFROST (0x6)
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleHvacFanDirection
     */
    HVAC_FAN_DIRECTION_AVAILABLE = (
        0x0511
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:SEAT),
    /**
     * Automatic recirculation on/off
     *
     * When automatic recirculation is ON, the HVAC system may automatically
     * switch to recirculation mode if the vehicle detects poor incoming air
     * quality.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_AUTO_RECIRC_ON = (
        0x0512
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),
    /**
     * Seat ventilation
     *
     * 0 indicates off.
     * Positive values indicates ventilation level.
     *
     * Used by HVAC apps and Assistant to enable, change, or read state of seat
     * ventilation.  This is different than seating cooling. It can be on at the
     * same time as cooling, or not.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_SEAT_VENTILATION = (
        0x0513
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Electric defrosters' status
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    HVAC_ELECTRIC_DEFROSTER_ON = (
        0x0514
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:WINDOW),
   /**
     * Distance units for display
     *
     * Indicates which units the car is using to display distances to the user. Eg. Mile, Meter
     * Kilometer.
     *
     * Distance units are defined in VehicleUnit.
     * VehiclePropConfig.configArray is used to indicate the supported distance display units.
     * For example: configArray[0] = METER
     *              configArray[1] = KILOMETER
     *              configArray[2] = MILE
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleUnit
     */
    DISTANCE_DISPLAY_UNITS = (
        0x0600
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Fuel volume units for display
     *
     * Indicates which units the car is using to display fuel volume to the user. Eg. Liter or
     * Gallon.
     *
     * VehiclePropConfig.configArray is used to indicate the supported fuel volume display units.
     * Volume units are defined in VehicleUnit.
     * For example: configArray[0] = LITER
     *              configArray[1] = GALLON
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleUnit
     */
    FUEL_VOLUME_DISPLAY_UNITS = (
        0x0601
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Tire pressure units for display
     *
     * Indicates which units the car is using to display tire pressure to the user. Eg. PSI, Bar or
     * Kilopascal.
     *
     * VehiclePropConfig.configArray is used to indicate the supported pressure display units.
     * Pressure units are defined in VehicleUnit.
     * For example: configArray[0] = KILOPASCAL
     *              configArray[1] = PSI
     *              configArray[2] = BAR
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleUnit
     */
    TIRE_PRESSURE_DISPLAY_UNITS = (
        0x0602
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * EV battery units for display
     *
     * Indicates which units the car is using to display EV battery information to the user. Eg.
     * watt-hours(Wh), kilowatt-hours(kWh) or ampere-hours(Ah).
     *
     * VehiclePropConfig.configArray is used to indicate the supported electrical energy units.
     * Electrical energy units are defined in VehicleUnit.
     * For example: configArray[0] = WATT_HOUR
     *              configArray[1] = AMPERE_HOURS
     *              configArray[2] = KILOWATT_HOUR
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleUnit
     */
    EV_BATTERY_DISPLAY_UNITS = (
        0x0603
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Fuel consumption units for display
     *
     * Indicates type of units the car is using to display fuel consumption information to user
     * True indicates units are distance over volume such as MPG.
     * False indicates units are volume over distance such as L/100KM.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    FUEL_CONSUMPTION_UNITS_DISTANCE_OVER_VOLUME = (
        0x0604
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * Speed units for display
     *
     * Indicates type of units the car is using to display speed to user. Eg. m/s, km/h, or mph.
     *
     * VehiclePropConfig.configArray is used to indicate the supported speed display units.
     * Pressure units are defined in VehicleUnit.
     * For example: configArray[0] = METER_PER_SEC
     *              configArray[1] = MILES_PER_HOUR
     *              configArray[2] = KILOMETERS_PER_HOUR
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    VEHICLE_SPEED_DISPLAY_UNITS = (
        0x0605
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Outside temperature
     *
     * @change_mode VehiclePropertyChangeMode:CONTINUOUS
     * @access VehiclePropertyAccess:READ
     * @unit VehicleUnit:CELSIUS
     */
    ENV_OUTSIDE_TEMPERATURE = (
        0x0703
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:FLOAT
        | VehicleArea:GLOBAL),
    /**
     * Property to control power state of application processor
     *
     * It is assumed that AP's power state is controlled by a separate power
     * controller.
     *
     * For configuration information, VehiclePropConfig.configArray can have bit flag combining
     * values in VehicleApPowerStateConfigFlag.
     *
     *   int32Values[0] : VehicleApPowerStateReq enum value
     *   int32Values[1] : additional parameter relevant for each state,
     *                    0 if not used.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    AP_POWER_STATE_REQ = (
        0x0A00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),
    /**
     * Property to report power state of application processor
     *
     * It is assumed that AP's power state is controller by separate power
     * controller.
     *
     *   int32Values[0] : VehicleApPowerStateReport enum value
     *   int32Values[1] : Time in ms to wake up, if necessary.  Otherwise 0.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    AP_POWER_STATE_REPORT = (
        0x0A01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),
    /**
     * Property to report bootup reason for the current power on. This is a
     * static property that will not change for the whole duration until power
     * off. For example, even if user presses power on button after automatic
     * power on with door unlock, bootup reason must stay with
     * VehicleApPowerBootupReason#USER_UNLOCK.
     *
     * int32Values[0] must be VehicleApPowerBootupReason.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
    */
    AP_POWER_BOOTUP_REASON = (
        0x0A02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Property to represent brightness of the display. Some cars have single
     * control for the brightness of all displays and this property is to share
     * change in that control.
     *
     * If this is writable, android side can set this value when user changes
     * display brightness from Settings. If this is read only, user may still
     * change display brightness from Settings, but that must not be reflected
     * to other displays.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DISPLAY_BRIGHTNESS = (
        0x0A03
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Property to feed H/W input events to android
     *
     * int32Values[0] : action defined by VehicleHwKeyInputAction
     * int32Values[1] : key code, must use standard android key code
     * int32Values[2] : target display defined in VehicleDisplay. Events not
     *                  tied to specific display must be sent to
     *                  VehicleDisplay#MAIN.
     * int32Values[3] : [optional] Number of ticks. The value must be equal or
     *                  greater than 1. When omitted, Android will default to 1.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @config_flags
     */
    HW_KEY_INPUT = (
        0x0A10
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),
    /**
     * Property to feed H/W rotary events to android
     *
     * int32Values[0] : RotaryInputType identifying which rotary knob rotated
     * int32Values[1] : number of detents (clicks), positive for clockwise,
     *                  negative for counterclockwise
     * int32Values[2] : target display defined in VehicleDisplay. Events not
     *                  tied to specific display must be sent to
     *                  VehicleDisplay#MAIN.
     * int32values[3 .. 3 + abs(number of detents) - 2]:
     *                  nanosecond deltas between pairs of consecutive detents,
     *                  if the number of detents is > 1 or < -1
     *
     * VehiclePropValue.timestamp: when the rotation occurred. If the number of
     *                             detents is > 1 or < -1, this is when the
     *                             first detent of rotation occurred.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @data_enum RotaryInputType
     * @access VehiclePropertyAccess:READ
     */
    HW_ROTARY_INPUT = (
        0x0A20
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32_VEC
        | VehicleArea:GLOBAL),
    /***************************************************************************
     * Most Car Cabin properties have both a POSition and MOVE parameter.  These
     * are used to control the various movements for seats, doors, and windows
     * in a vehicle.
     *
     * A POS parameter allows the user to set the absolution position.  For
     * instance, for a door, 0 indicates fully closed and max value indicates
     * fully open.  Thus, a value halfway between min and max must indicate
     * the door is halfway open.
     *
     * A MOVE parameter moves the device in a particular direction.  The sign
     * indicates direction, and the magnitude indicates speed (if multiple
     * speeds are available).  For a door, a move of -1 will close the door, and
     * a move of +1 will open it.  Once a door reaches the limit of open/close,
     * the door should automatically stop moving.  The user must NOT need to
     * send a MOVE(0) command to stop the door at the end of its range.
     **************************************************************************/
    /**
     * Door position
     *
     * This is an integer in case a door may be set to a particular position.
     * Max value indicates fully open, min value (0) indicates fully closed.
     *
     * Some vehicles (minivans) can open the door electronically.  Hence, the
     * ability to write this property.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_POS = (
        0x0B00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:DOOR),
    /**
     * Door move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_MOVE = (
        0x0B01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:DOOR),
    /**
     * Door lock
     *
     * 'true' indicates door is locked
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    DOOR_LOCK = (
        0x0B02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:DOOR),
    /**
     * Mirror Z Position
     *
     * Positive value indicates tilt upwards, negative value is downwards
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Z_POS = (
        0x0B40
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),
    /**
     * Mirror Z Move
     *
     * Positive value indicates tilt upwards, negative value is downwards
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Z_MOVE = (
        0x0B41
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),
    /**
     * Mirror Y Position
     *
     * Positive value indicate tilt right, negative value is left
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Y_POS = (
        0x0B42
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),
    /**
     * Mirror Y Move
     *
     * Positive value indicate tilt right, negative value is left
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_Y_MOVE = (
        0x0B43
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:MIRROR),
    /**
     * Mirror Lock
     *
     * True indicates mirror positions are locked and not changeable
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_LOCK = (
        0x0B44
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * Mirror Fold
     *
     * True indicates mirrors are folded
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    MIRROR_FOLD = (
        0x0B45
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * Seat memory select
     *
     * This parameter selects the memory preset to use to select the seat
     * position. The minValue is always 0, and the maxValue determines the
     * number of seat positions available.
     *
     * For instance, if the driver's seat has 3 memory presets, the maxValue
     * will be 3. When the user wants to select a preset, the desired preset
     * number (1, 2, or 3) is set.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    SEAT_MEMORY_SELECT = (
        0x0B80
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat memory set
     *
     * This setting allows the user to save the current seat position settings
     * into the selected preset slot.  The maxValue for each seat position
     * must match the maxValue for SEAT_MEMORY_SELECT.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    SEAT_MEMORY_SET = (
        0x0B81
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seatbelt buckled
     *
     * True indicates belt is buckled.
     *
     * Write access indicates automatic seat buckling capabilities.  There are
     * no known cars at this time, but you never know...
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_BUCKLED = (
        0x0B82
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:SEAT),
    /**
     * Seatbelt height position
     *
     * Adjusts the shoulder belt anchor point.
     * Max value indicates highest position
     * Min value indicates lowest position
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_HEIGHT_POS = (
        0x0B83
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seatbelt height move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BELT_HEIGHT_MOVE = (
        0x0B84
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat fore/aft position
     *
     * Sets the seat position forward (closer to steering wheel) and backwards.
     * Max value indicates closest to wheel, min value indicates most rearward
     * position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_FORE_AFT_POS = (
        0x0B85
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat fore/aft move
     *
     * Moves the seat position forward and aft.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_FORE_AFT_MOVE = (
        0x0B86
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat backrest angle 1 position
     *
     * Backrest angle 1 is the actuator closest to the bottom of the seat.
     * Max value indicates angling forward towards the steering wheel.
     * Min value indicates full recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_1_POS = (
        0x0B87
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat backrest angle 1 move
     *
     * Moves the backrest forward or recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_1_MOVE = (
        0x0B88
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat backrest angle 2 position
     *
     * Backrest angle 2 is the next actuator up from the bottom of the seat.
     * Max value indicates angling forward towards the steering wheel.
     * Min value indicates full recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_2_POS = (
        0x0B89
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat backrest angle 2 move
     *
     * Moves the backrest forward or recline.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_BACKREST_ANGLE_2_MOVE = (
        0x0B8A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat height position
     *
     * Sets the seat height.
     * Max value indicates highest position.
     * Min value indicates lowest position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEIGHT_POS = (
        0x0B8B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat height move
     *
     * Moves the seat height.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEIGHT_MOVE = (
        0x0B8C
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat depth position
     *
     * Sets the seat depth, distance from back rest to front edge of seat.
     * Max value indicates longest depth position.
     * Min value indicates shortest position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_DEPTH_POS = (
        0x0B8D
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat depth move
     *
     * Adjusts the seat depth.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_DEPTH_MOVE = (
        0x0B8E
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat tilt position
     *
     * Sets the seat tilt.
     * Max value indicates front edge of seat higher than back edge.
     * Min value indicates front edge of seat lower than back edge.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_TILT_POS = (
        0x0B8F
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat tilt move
     *
     * Tilts the seat.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_TILT_MOVE = (
        0x0B90
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Lumber fore/aft position
     *
     * Pushes the lumbar support forward and backwards
     * Max value indicates most forward position.
     * Min value indicates most rearward position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_FORE_AFT_POS = (
        0x0B91
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Lumbar fore/aft move
     *
     * Adjusts the lumbar support.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_FORE_AFT_MOVE = (
        0x0B92
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Lumbar side support position
     *
     * Sets the amount of lateral lumbar support.
     * Max value indicates widest lumbar setting (i.e. least support)
     * Min value indicates thinnest lumbar setting.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_SIDE_SUPPORT_POS = (
        0x0B93
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Lumbar side support move
     *
     * Adjusts the amount of lateral lumbar support.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_LUMBAR_SIDE_SUPPORT_MOVE = (
        0x0B94
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Headrest height position
     *
     * Sets the headrest height.
     * Max value indicates tallest setting.
     * Min value indicates shortest setting.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_HEIGHT_POS = (
        0x0B95
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Headrest height move
     *
     * Moves the headrest up and down.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_HEIGHT_MOVE = (
        0x0B96
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Headrest angle position
     *
     * Sets the angle of the headrest.
     * Max value indicates most upright angle.
     * Min value indicates shallowest headrest angle.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_ANGLE_POS = (
        0x0B97
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Headrest angle move
     *
     * Adjusts the angle of the headrest
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_ANGLE_MOVE = (
        0x0B98
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Headrest fore/aft position
     *
     * Adjusts the headrest forwards and backwards.
     * Max value indicates position closest to front of car.
     * Min value indicates position closest to rear of car.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_FORE_AFT_POS = (
        0x0B99
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Headrest fore/aft move
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SEAT_HEADREST_FORE_AFT_MOVE = (
        0x0B9A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Seat Occupancy
     *
     * Indicates whether a particular seat is occupied or not, to the best of the car's ability
     * to determine. Valid values are from the VehicleSeatOccupancyState enum.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleSeatOccupancyState
     */
    SEAT_OCCUPANCY = (
        0x0BB0
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Window Position
     *
     * Min = window up / closed
     * Max = window down / open
     *
     * For a window that may open out of plane (i.e. vent mode of sunroof) this
     * parameter will work with negative values as follows:
     *  Max = sunroof completely open
     *  0 = sunroof closed.
     *  Min = sunroof vent completely open
     *
     *  Note that in this mode, 0 indicates the window is closed.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_POS = (
        0x0BC0
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:WINDOW),
    /**
     * Window Move
     *
     * Max = Open the window as fast as possible
     * Min = Close the window as fast as possible
     * Magnitude denotes relative speed.  I.e. +2 is faster than +1 in closing
     * the window.
     *
     * For a window that may open out of plane (i.e. vent mode of sunroof) this
     * parameter will work as follows:
     *
     * If sunroof is open:
     *   Max = open the sunroof further, automatically stop when fully open.
     *   Min = close the sunroof, automatically stop when sunroof is closed.
     *
     * If vent is open:
     *   Max = close the vent, automatically stop when vent is closed.
     *   Min = open the vent further, automatically stop when vent is fully open.
     *
     * If sunroof is in the closed position:
     *   Max = open the sunroof, automatically stop when sunroof is fully open.
     *   Min = open the vent, automatically stop when vent is fully open.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_MOVE = (
        0x0BC1
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:WINDOW),
    /**
     * Window Lock
     *
     * True indicates windows are locked and can't be moved.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    WINDOW_LOCK = (
        0x0BC4
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:WINDOW),
    /**
     * Vehicle Maps Service (VMS) message
     *
     * This property uses MIXED data to communicate vms messages.
     *
     * Its contents are to be interpreted as follows:
     * the indices defined in VmsMessageIntegerValuesIndex are to be used to
     * read from int32Values;
     * bytes is a serialized VMS message as defined in the vms protocol
     * which is opaque to the framework;
     *
     * IVehicle#get must always return StatusCode::NOT_AVAILABLE.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    VEHICLE_MAP_SERVICE = (
        0x0C00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),
    /**
     * OBD2 Live Sensor Data
     *
     * Reports a snapshot of the current (live) values of the OBD2 sensors available.
     *
     * The configArray is set as follows:
     *   configArray[0] = number of vendor-specific integer-valued sensors
     *   configArray[1] = number of vendor-specific float-valued sensors
     *
     * The values of this property are to be interpreted as in the following example.
     * Considering a configArray = {2,3}
     * int32Values must be a vector containing Obd2IntegerSensorIndex.LAST_SYSTEM_INDEX + 2
     * elements (that is, 33 elements);
     * floatValues must be a vector containing Obd2FloatSensorIndex.LAST_SYSTEM_INDEX + 3
     * elements (that is, 73 elements);
     *
     * It is possible for each frame to contain a different subset of sensor values, both system
     * provided sensors, and vendor-specific ones. In order to support that, the bytes element
     * of the property value is used as a bitmask,.
     *
     * bytes must have a sufficient number of bytes to represent the total number of possible
     * sensors (in this case, 14 bytes to represent 106 possible values); it is to be read as
     * a contiguous bitmask such that each bit indicates the presence or absence of a sensor
     * from the frame, starting with as many bits as the size of int32Values, immediately
     * followed by as many bits as the size of floatValues.
     *
     * For example, should bytes[0] = 0x4C (0b01001100) it would mean that:
     *   int32Values[0 and 1] are not valid sensor values
     *   int32Values[2 and 3] are valid sensor values
     *   int32Values[4 and 5] are not valid sensor values
     *   int32Values[6] is a valid sensor value
     *   int32Values[7] is not a valid sensor value
     * Should bytes[5] = 0x61 (0b01100001) it would mean that:
     *   int32Values[32] is a valid sensor value
     *   floatValues[0 thru 3] are not valid sensor values
     *   floatValues[4 and 5] are valid sensor values
     *   floatValues[6] is not a valid sensor value
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    OBD2_LIVE_FRAME = (
        0x0D00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),
    /**
     * OBD2 Freeze Frame Sensor Data
     *
     * Reports a snapshot of the value of the OBD2 sensors available at the time that a fault
     * occurred and was detected.
     *
     * A configArray must be provided with the same meaning as defined for OBD2_LIVE_FRAME.
     *
     * The values of this property are to be interpreted in a similar fashion as those for
     * OBD2_LIVE_FRAME, with the exception that the stringValue field may contain a non-empty
     * diagnostic troubleshooting code (DTC).
     *
     * A IVehicle#get request of this property must provide a value for int64Values[0].
     * This will be interpreted as the timestamp of the freeze frame to retrieve. A list of
     * timestamps can be obtained by a IVehicle#get of OBD2_FREEZE_FRAME_INFO.
     *
     * Should no freeze frame be available at the given timestamp, a response of NOT_AVAILABLE
     * must be returned by the implementation. Because vehicles may have limited storage for
     * freeze frames, it is possible for a frame request to respond with NOT_AVAILABLE even if
     * the associated timestamp has been recently obtained via OBD2_FREEZE_FRAME_INFO.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    OBD2_FREEZE_FRAME = (
        0x0D01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),
    /**
     * OBD2 Freeze Frame Information
     *
     * This property describes the current freeze frames stored in vehicle
     * memory and available for retrieval via OBD2_FREEZE_FRAME.
     *
     * The values are to be interpreted as follows:
     * each element of int64Values must be the timestamp at which a a fault code
     * has been detected and the corresponding freeze frame stored, and each
     * such element can be used as the key to OBD2_FREEZE_FRAME to retrieve
     * the corresponding freeze frame.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     */
    OBD2_FREEZE_FRAME_INFO = (
        0x0D02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),
    /**
     * OBD2 Freeze Frame Clear
     *
     * This property allows deletion of any of the freeze frames stored in
     * vehicle memory, as described by OBD2_FREEZE_FRAME_INFO.
     *
     * The configArray is set as follows:
     *  configArray[0] = 1 if the implementation is able to clear individual freeze frames
     *                   by timestamp, 0 otherwise
     *
     * IVehicle#set of this property is to be interpreted as follows:
     *   if int64Values contains no elements, then all frames stored must be cleared;
     *   if int64Values contains one or more elements, then frames at the timestamps
     *   stored in int64Values must be cleared, and the others not cleared. Should the
     *   vehicle not support selective clearing of freeze frames, this latter mode must
     *   return NOT_AVAILABLE.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:WRITE
     */
    OBD2_FREEZE_FRAME_CLEAR = (
        0x0D03
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),
    /**
     * Headlights State
     *
     * Return the current state of headlights.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleLightState
     */
    HEADLIGHTS_STATE = (
        0x0E00
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * High beam lights state
     *
     * Return the current state of high beam lights.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleLightState
     */
    HIGH_BEAM_LIGHTS_STATE = (
        0x0E01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Fog light state
     *
     * Return the current state of fog lights.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleLightState
     */
    FOG_LIGHTS_STATE = (
        0x0E02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Hazard light status
     *
     * Return the current status of hazard lights.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleLightState
     */
    HAZARD_LIGHTS_STATE = (
        0x0E03
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Headlight switch
     *
     * The setting that the user wants.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleLightSwitch
     */
    HEADLIGHTS_SWITCH = (
        0x0E10
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * High beam light switch
     *
     * The setting that the user wants.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleLightSwitch
     */
    HIGH_BEAM_LIGHTS_SWITCH = (
        0x0E11
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Fog light switch
     *
     * The setting that the user wants.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleLightSwitch
     */
    FOG_LIGHTS_SWITCH = (
        0x0E12
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Hazard light switch
     *
     * The setting that the user wants.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleLightSwitch
     */
    HAZARD_LIGHTS_SWITCH = (
        0x0E13
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Cabin lights
     *
     * Return current status of cabin lights.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleLightState
     */
    CABIN_LIGHTS_STATE = (
        0x0F01
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Cabin lights switch
     *
     * The position of the physical switch which controls the cabin lights.
     * This might be different than the CABIN_LIGHTS_STATE if the lights are on because a door
     * is open or because of a voice command.
     * For example, while the switch is in the "off" or "automatic" position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleLightSwitch
     */
    CABIN_LIGHTS_SWITCH = (
        0x0F02
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:GLOBAL),
    /**
     * Reading lights
     *
     * Return current status of reading lights.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ
     * @data_enum VehicleLightState
     */
    READING_LIGHTS_STATE = (
        0x0F03
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Reading lights switch
     *
     * The position of the physical switch which controls the reading lights.
     * This might be different than the READING_LIGHTS_STATE if the lights are on because a door
     * is open or because of a voice command.
     * For example, while the switch is in the "off" or "automatic" position.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     * @data_enum VehicleLightSwitch
     */
    READING_LIGHTS_SWITCH = (
        0x0F04
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:INT32
        | VehicleArea:SEAT),
    /**
     * Support customize permissions for vendor properties
     *
     * Implement this property if vehicle hal support customize vendor permissions feature.
     * VehiclePropConfig.configArray is used to indicate vendor properties and permissions
     * which selected for this vendor property. The permission must be one of enum in
     * VehicleVendorPermission.
     * The configArray is set as follows:
     *      configArray[n] = propId : property ID for the vendor property
     *      configArray[n+1] = one of enums in VehicleVendorPermission. It indicates the permission
     *      for reading value of the property.
     *      configArray[n+2] = one of enums in VehicleVendorPermission. It indicates the permission
     *      for writing value of the property.
     *
     * For example:
     * configArray = {
     *      vendor_prop_1, PERMISSION_VENDOR_SEAT_READ, PERMISSION_VENDOR_SEAT_WRITE,
     *      vendor_prop_2, PERMISSION_VENDOR_INFO, PERMISSION_NOT_ACCESSIBLE,
     * }
     * If vendor properties are not in this array, they will have the default vendor permission.
     * If vendor chose PERMISSION_NOT_ACCESSIBLE, android will not have access to the property. In
     * the example, Android can not write value for vendor_prop_2.
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    SUPPORT_CUSTOMIZE_VENDOR_PERMISSION = (
        0x0F05
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:BOOLEAN
        | VehicleArea:GLOBAL),
    /**
     * Allow disabling optional featurs from vhal.
     *
     * This property reports optional features that should be disabled.
     * All allowed optional features for the system is declared in Car service overlay,
     * config_allowed_optional_car_features.
     * This property allows disabling features defined in the overlay. Without this property,
     * all the features declared in the overlay will be enabled.
     *
     * Value read should include all features disabled with ',' separation.
     * ex) "com.android.car.user.CarUserNoticeService,storage_monitoring"
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:READ
     */
    DISABLED_OPTIONAL_FEATURES = (
        0x0F06
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:STRING
        | VehicleArea:GLOBAL),
    /**
     * Defines the initial Android user to be used during initialization.
     *
     * This property is called by the Android system when it initializes and it lets the HAL
     * define which Android user should be started.
     *
     * This request is made by setting a VehiclePropValue (defined by InitialUserInfoRequest),
     * and the HAL must respond with a property change event (defined by InitialUserInfoResponse).
     * If the HAL doesn't respond after some time (defined by the Android system), the Android
     * system will proceed as if HAL returned a response of action
     * InitialUserInfoResponseAction:DEFAULT.
     *
     * For example, on first boot, the request could be:
     *
     * int32[0]: 42  // request id (arbitrary number set by Android system)
     * int32[1]: 1   // InitialUserInfoRequestType::FIRST_BOOT
     * int32[2]: 0   // id of current user (usersInfo.currentUser.userId)
     * int32[3]: 1   // flag of current user (usersInfo.currentUser.flags = SYSTEM)
     * int32[4]: 1   // number of existing users (usersInfo.numberUsers);
     * int32[5]: 0   // user #0  (usersInfo.existingUsers[0].userId)
     * int32[6]: 1   // flags of user #0  (usersInfo.existingUsers[0].flags)
     *
     * And if the HAL want to respond with the creation of an admin user called "Owner", the
     * response would be:
     *
     * int32[0]: 42      // must match the request id from the request
     * int32[1]:  2      // action = InitialUserInfoResponseAction::CREATE
     * int32[2]: -10000  // userToSwitchOrCreate.userId (not used as user will be created)
     * int32[3]:  8      // userToSwitchOrCreate.flags = ADMIN
     * string: "||Owner" // userLocales + separator + userNameToCreate
     *
     * Notice the string value represents multiple values, separated by ||. The first value is the
     * (optional) system locales for the user to be created (in this case, it's empty, meaning it
     * will use Android's default value), while the second value is the (also optional) name of the
     * to user to be created (when the type of response is InitialUserInfoResponseAction:CREATE).
     * For example, to create the same "Owner" user with "en-US" and "pt-BR" locales, the string
     * value of the response would be "en-US,pt-BR||Owner". As such, neither the locale nor the
     * name can have || on it, although a single | is fine.
     *
     * NOTE: if the HAL doesn't support user management, then it should not define this property,
     * which in turn would disable the other user-related properties (for example, the Android
     * system would never issue them and user-related requests from the HAL layer would be ignored
     * by the Android System). But if it supports user management, then it must support all core
     * user-related properties (INITIAL_USER_INFO, SWITCH_USER, CREATE_USER, and REMOVE_USER).
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    INITIAL_USER_INFO = (
        0x0F07
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),
    /**
     * Defines a request to switch the foreground Android user.
     *
     * This property is used primarily by the Android System to inform the HAL that the
     * current foreground Android user is switching, but it could also be used by the HAL to request
     * the Android system to switch users - the
     *
     * When the request is made by Android, it sets a VehiclePropValue and the HAL must responde
     * with a property change event; when the HAL is making the request, it must also do it through
     * a property change event (the main difference is that the request id will be positive in the
     * former case, and negative in the latter; the SwitchUserMessageType will also be different).
     *
     * The format of both request is defined by SwitchUserRequest and the format of the response
     * (when needed) is defined by SwitchUserResponse. How the HAL (or Android System) should
     * proceed depends on the message type (which is defined by the SwitchUserMessageType
     * parameter), as defined below.
     *
     * 1.LEGACY_ANDROID_SWITCH
     * -----------------------
     *
     * Called by the Android System to indicate the Android user is about to change, when the change
     * request was made in a way that is not integrated with the HAL (for example, through
     * adb shell am switch-user).
     *
     * The HAL can switch its internal user once it receives this request, but it doesn't need to
     * reply back to the Android System. If its internal user cannot be changed for some reason,
     * then it must wait for the SWITCH_USER(type=ANDROID_POST_SWITCH) call to recover
     * (for example, it could issue a SWITCH_USER(type=VEHICLE_REQUEST) to switch back to
     * the previous user), but ideally it should never fail (as switching back could result in a
     * confusing experience for the end user).
     *
     * For example, if the system have users (0, 10, 11) and it's switching from 0 to 11 (where none
     * of them have any special flag), the request would be:
     *
     * int32[0]:  42  // request id
     * int32[1]:  1   // SwitchUserMessageType::LEGACY_ANDROID_SWITCH
     * int32[2]:  11  // target user id
     * int32[3]:  0   // target user flags (none)
     * int32[4]:  10  // current user
     * int32[5]:  0   // current user flags (none)
     * int32[6]:  3   // number of users
     * int32[7]:  0   // user #0 (Android user id 0)
     * int32[8]:  0   // flags of user #0 (none)
     * int32[9]:  10  // user #1 (Android user id 10)
     * int32[10]: 0   // flags of user #1 (none)
     * int32[11]: 11  // user #2 (Android user id 11)
     * int32[12]: 0   // flags of user #2 (none)
     *
     * 2.ANDROID_SWITCH
     * ----------------
     * Called by the Android System to indicate the Android user is about to change, but Android
     * will wait for the HAL's response (up to some time) before proceeding.
     *
     * The HAL must switch its internal user once it receives this request, then respond back to
     * Android with a SWITCH_USER(type=VEHICLE_RESPONSE) indicating whether its internal
     * user was switched or not (through the SwitchUserStatus enum).
     *
     * For example, if Android has users (0, 10, 11) and it's switching from 10 to 11 (where
     * none of them have any special flag), the request would be:
     *
     * int32[0]:  42  // request id
     * int32[1]:  2   // SwitchUserMessageType::ANDROID_SWITCH
     * int32[2]:  11  // target user id
     * int32[3]:  0   // target user flags (none)
     * int32[4]:  10  // current user
     * int32[5]:  0   // current user flags (none)
     * int32[6]:  3   // number of users
     * int32[7]:  0   // 1st user (user 0)
     * int32[8]:  1   // 1st user flags (SYSTEM)
     * int32[9]:  10  // 2nd user (user 10)
     * int32[10]: 0   // 2nd user flags (none)
     * int32[11]: 11  // 3rd user (user 11)
     * int32[12]: 0   // 3rd user flags (none)
     *
     * If the request succeeded, the HAL must update the propery with:
     *
     * int32[0]: 42  // request id
     * int32[1]: 3   // messageType = SwitchUserMessageType::VEHICLE_RESPONSE
     * int32[2]: 1   // status = SwitchUserStatus::SUCCESS
     *
     * But if it failed, the response would be something like:
     *
     * int32[0]: 42   // request id
     * int32[1]: 3    // messageType = SwitchUserMessageType::VEHICLE_RESPONSE
     * int32[2]: 2    // status = SwitchUserStatus::FAILURE
     * string: "108-D'OH!" // OEM-spefic error message
     *
     * 3.VEHICLE_RESPONSE
     * ------------------
     * Called by the HAL to indicate whether a request of type ANDROID_SWITCH should proceed or
     * abort - see the ANDROID_SWITCH section above for more info.
     *
     * 4.VEHICLE_REQUEST
     * ------------------
     * Called by the HAL to request that the current foreground Android user is switched.
     *
     * This is useful in situations where Android started as one user, but the vehicle identified
     * the driver as another user. For example, user A unlocked the car using the key fob of user B;
     * the INITIAL_USER_INFO request returned user B, but then a face recognition subsubsystem
     * identified the user as A.
     *
     * The HAL makes this request by a property change event (passing a negative request id), and
     * the Android system will response by issue an ANDROID_POST_SWITCH call which the same
     * request id.
     *
     * For example, if the current foreground Android user is 10 and the HAL asked it to switch to
     * 11, the request would be:
     *
     * int32[0]: -108  // request id
     * int32[1]: 4     // messageType = SwitchUserMessageType::VEHICLE_REQUEST
     * int32[2]: 11    // Android user id
     *
     * If the request succeeded and Android has 3 users (0, 10, 11), the response would be:
     *
     * int32[0]: -108 // request id
     * int32[1]:  5   // messageType = SwitchUserMessageType::ANDROID_POST_SWITCH
     * int32[2]:  11  // target user id
     * int32[3]:  0   // target user id flags (none)
     * int32[4]:  11  // current user
     * int32[5]:  0   // current user flags (none)
     * int32[6]:  3   // number of users
     * int32[7]:  0   // 1st user (user 0)
     * int32[8]:  0   // 1st user flags (none)
     * int32[9]:  10  // 2nd user (user 10)
     * int32[10]: 4   // 2nd user flags (none)
     * int32[11]: 11  // 3rd user (user 11)
     * int32[12]: 3   // 3rd user flags (none)
     *
     * Notice that both the current and target user ids are the same - if the request failed, then
     * they would be different (i.e, target user would be 11, but current user would still be 10).
     *
     * 5.ANDROID_POST_SWITCH
     * ---------------------
     * Called by the Android System after a request to switch a user was made.
     *
     * This property is called after switch requests of any type (i.e., LEGACY_ANDROID_SWITCH,
     * ANDROID_SWITCH, or VEHICLE_REQUEST) and can be used to determine if the request succeeded or
     * failed:
     *
     * 1. When it succeeded, it's called when the Android user is in the unlocked state and the
     *    value of the current and target users ids in the response are the same. This would be
     *    equivalent to receiving an Intent.ACTION_USER_UNLOCKED in an Android app.
     * 2. When it failed it's called right away and the value of the current and target users ids
     *    in the response are different (as the current user didn't change to the target).
     * 3. If a new switch request is made before the HAL responded to the previous one or before
     *    the user was unlocked, then the ANDROID_POST_SWITCH request is not made. For example,
     *    the driver could accidentally switch to the wrong user which has lock credentials, then
     *    switch to the right one before entering the credentials.
     *
     * The HAL can update its internal state once it receives this request, but it doesn't need to
     * reply back to the Android System.
     *
     * Request: the first N values as defined by INITIAL_USER_INFO (where the request-specific
     * value at index 1 is SwitchUserMessageType::ANDROID_POST_SWITCH), then 2 more values for the
     * target user id (i.e., the Android user id that was requested to be switched to) and its flags
     * (as defined by  UserFlags).
     *
     * Response: none.
     *
     * Example: see VEHICLE_REQUEST section above.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    SWITCH_USER = (
        0x0F08
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),
    /**
     * Called by the Android System after an Android user was created.
     *
     * The HAL can use this property to create its equivalent user.
     *
     * This is an async request: Android makes the request by setting a VehiclePropValue, and HAL
     * must respond with a property change indicating whether the request succeeded or failed. If
     * it failed, the Android system will remove the user.
     *
     * The format of the request is defined by CreateUserRequest and the format of the response by
     * CreateUserResponse.
     *
     * For example, if system had 2 users (0 and 10) and a 3rd one (which is an ephemeral guest) was
     * created, the request would be:
     *
     * int32[0]: 42  // request id
     * int32[1]: 11  // Android id of the created user
     * int32[2]: 3   // Android flags (ephemeral guest) of the created user
     * int32[3]: 10  // current user
     * int32[4]: 0   // current user flags (none)
     * int32[5]: 3   // number of users
     * int32[6]: 0   // 1st user (user 0)
     * int32[7]: 0   // 1st user flags (none)
     * int32[8]: 10  // 2nd user (user 10)
     * int32[9]: 0   // 2nd user flags (none)
     * int32[19]: 11 // 3rd user (user 11)
     * int32[11]: 3  // 3rd user flags (ephemeral guest)
     * string: "ElGuesto" // name of the new user
     *
     * Then if the request succeeded, the HAL would return:
     *
     * int32[0]: 42  // request id
     * int32[1]: 1   // CreateUserStatus::SUCCESS
     *
     * But if it failed:
     *
     * int32[0]: 42  // request id
     * int32[1]: 2   // CreateUserStatus::FAILURE
     * string: "D'OH!" // The meaning is a blackbox - it's passed to the caller (like Settings UI),
     *                 // which in turn can take the proper action.
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    CREATE_USER = (
        0x0F09
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),
    /**
     * Called by the Android System after an Android user was removed.
     *
     * The HAL can use this property to remove its equivalent user.
     *
     * This is write-only call - the Android System is not expecting a reply from the HAL. Hence,
     * this request should not fail - if the equivalent HAL user cannot be removed, then HAL should
     * mark it as inactive or recover in some other way.
     *
     * The request is made by setting the VehiclePropValue with the contents defined by
     * RemoveUserRequest.
     *
     * For example, if system had 3 users (0, 10, and 11) and user 11 was removed, the request
     * would be:
     *
     * int32[0]: 42  // request id
     * int32[1]: 11  // (Android user id of the removed user)
     * int32[2]: 0   // (Android user flags of the removed user)
     * int32[3]: 10  // current user
     * int32[4]: 0   // current user flags (none)
     * int32[5]: 2   // number of users
     * int32[6]: 0   // 1st user (user 0)
     * int32[7]: 0   // 1st user flags (none)
     * int32[8]: 10  // 2nd user (user 10)
     * int32[9]: 0   // 2nd user flags (none)
     *
     * @change_mode VehiclePropertyChangeMode:STATIC
     * @access VehiclePropertyAccess:WRITE
     */
    REMOVE_USER = (
        0x0F0A
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),
    /**
     * Property used to associate (or query the association) the current user with vehicle-specific
     * identification mechanisms (such as key FOB).
     *
     * This is an optional user management property - the OEM could still support user management
     * without defining it. In fact, this property could be used without supporting the core
     * user-related functions described on INITIAL_USER_INFO.
     *
     * To query the association, the Android system gets the property, passing a VehiclePropValue
     * containing the types of associations are being queried, as defined by
     * UserIdentificationGetRequest. The HAL must return right away, returning a VehiclePropValue
     * with a UserIdentificationResponse. Notice that user identification should have already
     * happened while system is booting up and the VHAL implementation should only return the
     * already identified association (like the key FOB used to unlock the car), instead of starting
     * a new association from the get call.
     *
     * To associate types, the Android system sets the property, passing a VehiclePropValue
     * containing the types and values of associations being set, as defined by the
     * UserIdentificationSetRequest. The HAL will then use a property change event (whose
     * VehiclePropValue is defined by UserIdentificationResponse) indicating the current status of
     * the types after the request.
     *
     * For example, to query if the current user (10) is associated with the FOB that unlocked the
     * car and a custom mechanism provided by the OEM, the request would be:
     *
     * int32[0]: 42  // request id
     * int32[1]: 10  (Android user id)
     * int32[2]: 0   (Android user flags)
     * int32[3]: 2   (number of types queried)
     * int32[4]: 1   (1st type queried, UserIdentificationAssociationType::KEY_FOB)
     * int32[5]: 101 (2nd type queried, UserIdentificationAssociationType::CUSTOM_1)
     *
     * If the user is associated with the FOB but not with the custom mechanism, the response would
     * be:
     *
     * int32[0]: 42  // request id
     * int32[1]: 2   (number of associations in the response)
     * int32[2]: 1   (1st type: UserIdentificationAssociationType::KEY_FOB)
     * int32[3]: 2   (1st value: UserIdentificationAssociationValue::ASSOCIATED_CURRENT_USER)
     * int32[4]: 101 (2st type: UserIdentificationAssociationType::CUSTOM_1)
     * int32[5]: 4   (2nd value: UserIdentificationAssociationValue::NOT_ASSOCIATED_ANY_USER)
     *
     * Then to associate the user with the custom mechanism, a set request would be made:
     *
     * int32[0]: 43  // request id
     * int32[1]: 10  (Android user id)
     * int32[2]: 0   (Android user flags)
     * int32[3]: 1   (number of associations being set)
     * int32[4]: 101 (1st type: UserIdentificationAssociationType::CUSTOM_1)
     * int32[5]: 1   (1st value: UserIdentificationAssociationSetValue::ASSOCIATE_CURRENT_USER)
     *
     * If the request succeeded, the response would be simply:
     *
     * int32[0]: 43  // request id
     * int32[1]: 1   (number of associations in the response)
     * int32[2]: 101 (1st type: UserIdentificationAssociationType::CUSTOM_1)
     * int32[3]: 1   (1st value: UserIdentificationAssociationValue::ASSOCIATED_CURRENT_USER)
     *
     * Notice that the set request adds associations, but doesn't remove the existing ones. In the
     * example above, the end state would be 2 associations (FOB and CUSTOM_1). If we wanted to
     * associate the user with just CUSTOM_1 but not FOB, then the request should have been:
     *
     * int32[0]: 43  // request id
     * int32[1]: 10  (Android user id)
     * int32[2]: 2   (number of types set)
     * int32[3]: 1   (1st type: UserIdentificationAssociationType::KEY_FOB)
     * int32[4]: 2   (1st value: UserIdentificationAssociationValue::DISASSOCIATE_CURRENT_USER)
     * int32[5]: 101 (2nd type: UserIdentificationAssociationType::CUSTOM_1)
     * int32[6]: 1   (2nd value: UserIdentificationAssociationValue::ASSOCIATE_CURRENT_USER)
     *
     * @change_mode VehiclePropertyChangeMode:ON_CHANGE
     * @access VehiclePropertyAccess:READ_WRITE
     */
    USER_IDENTIFICATION_ASSOCIATION = (
        0x0F0B
        | VehiclePropertyGroup:SYSTEM
        | VehiclePropertyType:MIXED
        | VehicleArea:GLOBAL),
};
/**
 * Used by SUPPORT_CUSTOMIZE_VENDOR_PERMISSION to indicate the permission of vendor properties.
 */
enum VehicleVendorPermission : int32_t {
    PERMISSION_DEFAULT = 0x00000000,
    // permissions for the property related with window
    PERMISSION_SET_VENDOR_CATEGORY_WINDOW= 0X00000001,
    PERMISSION_GET_VENDOR_CATEGORY_WINDOW = 0x00000002,
    // permissions for the property related with door
    PERMISSION_SET_VENDOR_CATEGORY_DOOR  = 0x00000003,
    PERMISSION_GET_VENDOR_CATEGORY_DOOR   = 0x00000004,
    // permissions for the property related with seat
    PERMISSION_SET_VENDOR_CATEGORY_SEAT  = 0x00000005,
    PERMISSION_GET_VENDOR_CATEGORY_SEAT   = 0x00000006,
    // permissions for the property related with mirror
    PERMISSION_SET_VENDOR_CATEGORY_MIRROR= 0x00000007,
    PERMISSION_GET_VENDOR_CATEGORY_MIRROR = 0x00000008,
    // permissions for the property related with car's information
    PERMISSION_SET_VENDOR_CATEGORY_INFO  = 0x00000009,
    PERMISSION_GET_VENDOR_CATEGORY_INFO   = 0x0000000A,
    // permissions for the property related with car's engine
    PERMISSION_SET_VENDOR_CATEGORY_ENGINE= 0x0000000B,
    PERMISSION_GET_VENDOR_CATEGORY_ENGINE = 0x0000000C,
    // permissions for the property related with car's HVAC
    PERMISSION_SET_VENDOR_CATEGORY_HVAC  = 0x0000000D,
    PERMISSION_GET_VENDOR_CATEGORY_HVAC   = 0x0000000E,
    // permissions for the property related with car's light
    PERMISSION_SET_VENDOR_CATEGORY_LIGHT = 0x0000000F,
    PERMISSION_GET_VENDOR_CATEGORY_LIGHT  = 0x00000010,
    // permissions reserved for other vendor permission
    PERMISSION_SET_VENDOR_CATEGORY_1  = 0x00010000,
    PERMISSION_GET_VENDOR_CATEGORY_1   = 0x00011000,
    PERMISSION_SET_VENDOR_CATEGORY_2  = 0x00020000,
    PERMISSION_GET_VENDOR_CATEGORY_2   = 0x00021000,
    PERMISSION_SET_VENDOR_CATEGORY_3  = 0x00030000,
    PERMISSION_GET_VENDOR_CATEGORY_3   = 0x00031000,
    PERMISSION_SET_VENDOR_CATEGORY_4  = 0x00040000,
    PERMISSION_GET_VENDOR_CATEGORY_4   = 0x00041000,
    PERMISSION_SET_VENDOR_CATEGORY_5  = 0x00050000,
    PERMISSION_GET_VENDOR_CATEGORY_5   = 0x00051000,
    PERMISSION_SET_VENDOR_CATEGORY_6  = 0x00060000,
    PERMISSION_GET_VENDOR_CATEGORY_6   = 0x00061000,
    PERMISSION_SET_VENDOR_CATEGORY_7  = 0x00070000,
    PERMISSION_GET_VENDOR_CATEGORY_7   = 0x00071000,
    PERMISSION_SET_VENDOR_CATEGORY_8  = 0x00080000,
    PERMISSION_GET_VENDOR_CATEGORY_8   = 0x00081000,
    PERMISSION_SET_VENDOR_CATEGORY_9  = 0x00090000,
    PERMISSION_GET_VENDOR_CATEGORY_9   = 0x00091000,
    PERMISSION_SET_VENDOR_CATEGORY_10 = 0x000A0000,
    PERMISSION_GET_VENDOR_CATEGORY_10  = 0x000A1000,
    // Indicate not available for android to access.
    PERMISSION_NOT_ACCESSIBLE = 0xF0000000
};
/**
 * Used by seat occupancy to enumerate the current occupancy state of the seat.
 */
enum  VehicleSeatOccupancyState : int32_t {
    UNKNOWN = 0,
    VACANT = 1,
    OCCUPIED = 2
};
/**
 * Used by lights state properties to enumerate the current state of the lights.
 *
 * Most XXX_LIGHTS_STATE properties will only report ON and OFF states.  Only
 * the HEADLIGHTS_STATE property will report DAYTIME_RUNNING.
 */
enum  VehicleLightState : int32_t {
    OFF = 0,
    ON = 1,
    DAYTIME_RUNNING = 2
};
/**
 * Used by lights switch properties to enumerate user selected switch setting.
 *
 * XXX_LIGHTS_SWITCH properties report the switch settings that the user
 * selects.  The switch setting may be decoupled from the state reported if the
 * user selects AUTOMATIC.
 */
enum VehicleLightSwitch : int32_t {
    OFF = 0,
    ON = 1,
    /**
     * Daytime running lights mode.  Most cars automatically use DRL but some
     * cars allow the user to activate them manually.
     */
    DAYTIME_RUNNING = 2,
    /**
     * Allows the vehicle ECU to set the lights automatically
     */
    AUTOMATIC = 0x100,
};
/**
 * Used by INFO_EV_CONNECTOR_TYPE to enumerate the type of connectors
 * available to charge the vehicle.
 */
enum EvConnectorType : int32_t {
    /**
     * Default type if the vehicle does not know or report the EV connector
     * type.
     */
    UNKNOWN = 0,
    IEC_TYPE_1_AC = 1,              // aka Yazaki
    IEC_TYPE_2_AC = 2,              // aka Mennekes
    IEC_TYPE_3_AC = 3,              // aka Scame
    IEC_TYPE_4_DC = 4,              // aka CHAdeMO
    IEC_TYPE_1_CCS_DC = 5,          // aka Combo 1
    IEC_TYPE_2_CCS_DC = 6,          // aka Combo 2
    TESLA_ROADSTER = 7,
    TESLA_HPWC = 8,
    TESLA_SUPERCHARGER = 9,
    GBT_AC = 10,
    GBT_DC = 11,
    /**
     * Connector type to use when no other types apply. Before using this
     * value, work with Google to see if the EvConnectorType enum can be
     * extended with an appropriate value.
     */
    OTHER = 101,
};
/**
 * Used by INFO_FUEL_DOOR_LOCATION/INFO_CHARGE_PORT_LOCATION to enumerate fuel door or
 * ev port location.
 */
enum PortLocationType : int32_t {
    /**
     * Default type if the vehicle does not know or report the Fuel door
     * and ev port location.
     */
    UNKNOWN = 0,
    FRONT_LEFT = 1,
    FRONT_RIGHT = 2,
    REAR_RIGHT = 3,
    REAR_LEFT = 4,
    FRONT = 5,
    REAR = 6,
};
/**
 * Used by INFO_FUEL_TYPE to enumerate the type of fuels this vehicle uses.
 * Consistent with projection protocol.
 */
enum FuelType : int32_t {
    /**
     * Fuel type to use if the HU does not know on which types of fuel the vehicle
     * runs. The use of this value is generally discouraged outside of aftermarket units.
     */
    FUEL_TYPE_UNKNOWN = 0,
    /** Unleaded gasoline */
    FUEL_TYPE_UNLEADED = 1,
    /** Leaded gasoline */
    FUEL_TYPE_LEADED = 2,
    /** Diesel #1 */
    FUEL_TYPE_DIESEL_1 = 3,
    /** Diesel #2 */
    FUEL_TYPE_DIESEL_2 = 4,
    /** Biodiesel */
    FUEL_TYPE_BIODIESEL = 5,
    /** 85% ethanol/gasoline blend */
    FUEL_TYPE_E85 = 6,
    /** Liquified petroleum gas */
    FUEL_TYPE_LPG = 7,
    /** Compressed natural gas */
    FUEL_TYPE_CNG = 8,
    /** Liquified natural gas */
    FUEL_TYPE_LNG = 9,
    /** Electric */
    FUEL_TYPE_ELECTRIC = 10,
    /** Hydrogen fuel cell */
    FUEL_TYPE_HYDROGEN = 11,
    /**
     * Fuel type to use when no other types apply. Before using this value, work with
     * Google to see if the FuelType enum can be extended with an appropriate value.
     */
    FUEL_TYPE_OTHER = 12,
};
/**
 * Bit flags for fan direction
 */
enum VehicleHvacFanDirection : int32_t {
    UNKNOWN = 0x0,
    FACE = 0x1,
    FLOOR = 0x2,
    /**
     * FACE_AND_FLOOR = FACE | FLOOR
     */
    FACE_AND_FLOOR = 0x3,
    DEFROST = 0x4,
    /**
     * DEFROST_AND_FLOOR = DEFROST | FLOOR
     */
    DEFROST_AND_FLOOR = 0x06,
};
enum VehicleOilLevel : int32_t {
    /**
     * Oil level values
     */
    CRITICALLY_LOW = 0,
    LOW = 1,
    NORMAL = 2,
    HIGH = 3,
    ERROR = 4,
};
enum VehicleApPowerStateConfigFlag : int32_t {
    /**
     * AP can enter deep sleep state. If not set, AP will always shutdown from
     * VehicleApPowerState#SHUTDOWN_PREPARE power state.
     */
    ENABLE_DEEP_SLEEP_FLAG = 0x1,
    /**
     * The power controller can power on AP from off state after timeout
     * specified in VehicleApPowerSet VEHICLE_AP_POWER_SET_SHUTDOWN_READY message.
     */
    CONFIG_SUPPORT_TIMER_POWER_ON_FLAG = 0x2,
};
enum VehicleApPowerStateReq : int32_t {
    /**
     * This requests Android to enter its normal operating state.
     * This may be sent after the AP has reported
     * VehicleApPowerStateReport#DEEP_SLEEP_EXIT,
     * VehicleApPowerStateReport#SHUTDOWN_CANCELLED, or
     * VehicleApPowerStateReport#WAIT_FOR_VHAL.
     */
    ON = 0,
    /**
     * The power controller issues this request to shutdown the system.
     * This may be sent after the AP has reported
     * VehicleApPowerStateReport#DEEP_SLEEP_EXIT,
     * VehicleApPowerStateReport#ON,
     * VehicleApPowerStateReport#SHUTDOWN_CANCELLED,
     * VehicleApPowerStateReport#SHUTDOWN_POSTPONE,
     * VehicleApPowerStateReport#SHUTDOWN_PREPARE, or
     * VehicleApPowerStateReport#WAIT_FOR_VHAL.
     *
     * int32Values[1] : One of VehicleApPowerStateShutdownParam.
     *                  This parameter indicates if the AP should shut
     *                  down fully or sleep. This parameter also
     *                  indicates if the shutdown should be immediate
     *                  or if it can be postponed. If the shutdown can
     *                  be postponed, AP requests postponing by sending
     *                  VehicleApPowerStateReport#SHUTDOWN_POSTPONE.
     */
    SHUTDOWN_PREPARE = 1,
    /**
     * Cancel the shutdown.
     * This may be sent after the AP has reported
     * VehicleApPowerStateReport#SHUTDOWN_POSTPONE or
     * VehicleApPowerStateReport#SHUTDOWN_PREPARE.
     * After receiving this request, the AP will report
     * VehicleApPowerStateReport#WAIT_FOR_VHAL in preparation to going ON.
     */
    CANCEL_SHUTDOWN = 2,
    /**
     * Completes the shutdown process.
     * This may be sent after the AP has reported
     * VehicleApPowerStateReport#DEEP_SLEEP_ENTRY or
     * VehicleApPowerStateReport#SHUTDOWN_START. The AP will not report new
     * state information after receiving this request.
     */
    FINISHED = 3,
};
/**
 * Index in int32Values for VehicleProperty#AP_POWER_STATE_REQ property.
 */
enum VehicleApPowerStateReqIndex : int32_t {
    STATE = 0,
    ADDITIONAL = 1,
};
enum VehicleApPowerStateShutdownParam : int32_t {
    /** AP must shutdown immediately. Postponing is not allowed. */
    SHUTDOWN_IMMEDIATELY = 1,
    /** AP can enter deep sleep instead of shutting down completely. */
    CAN_SLEEP = 2,
    /** AP can only shutdown with postponing allowed. */
    SHUTDOWN_ONLY = 3,
    /**
     * AP may enter deep sleep, but must either sleep or shut down immediately.
     * Postponing is not allowed. */
    SLEEP_IMMEDIATELY = 4,
};
enum VehicleApPowerStateReport : int32_t {
    /**
     * The device has booted. CarService has initialized and is ready to accept commands
     * from VHAL. The user is not logged in, and vendor apps and services are expected to
     * control the display and audio.
     * After reporting this state, AP will accept VehicleApPowerStateReq#ON or
     * VehicleApPowerStateReq#SHUTDOWN_PREPARE. Other power state requests are ignored.
     */
    WAIT_FOR_VHAL = 0x1,
    /**
     * AP is ready to suspend.
     * The AP will not send any more state reports after this.
     * After reporting this state, AP will accept VehicleApPowerStateReq#FINISHED.
     * Other power state requests are ignored.
     *
     * int32Values[1]: Time to turn AP back on, in seconds. Power controller should turn on
     *                 AP after the specified time has elapsed, so AP can run tasks like
     *                 update. If this value is 0, no wake up is requested. The power
     *                 controller may not necessarily support timed wake-up.
     */
    DEEP_SLEEP_ENTRY = 0x2,
    /**
     * AP is exiting from deep sleep state.
     * After reporting this state, AP will accept VehicleApPowerStateReq#ON or
     * VehicleApPowerStateReq#SHUTDOWN_PREPARE. Other power state requests are ignored.
     */
    DEEP_SLEEP_EXIT = 0x3,
    /**
     * AP sends this message repeatedly while cleanup and idle tasks execute.
     * After reporting this state, AP will accept VehicleApPowerStateReq#SHUTDOWN_PREPARE
     * requesting immediate shutdown or VehicleApPowerStateReq#CANCEL_SHUTDOWN. Other
     * power state requests are ignored.
     *
     * int32Values[1]: Time to postpone shutdown in ms. Maximum value is
     *                 5000 ms.
     *                 If AP needs more time, it will send another SHUTDOWN_POSTPONE
     *                 message before the previous one expires.
     */
    SHUTDOWN_POSTPONE = 0x4,
    /**
     * AP is ready to shutdown.
     * The AP will not send any more state reports after this.
     * After reporting this state, AP will accept VehicleApPowerStateReq#FINISHED.
     * Other power state requests are ignored.
     *
     * int32Values[1]: Time to turn AP back on, in seconds. Power controller should turn on
     *                 AP after the specified time has elapsed so AP can run tasks like
     *                 update. If this value is 0, no wake up is specified. The power
     *                 controller may not necessarily support timed wake-up.
     */
    SHUTDOWN_START = 0x5,
    /**
     * AP is entering its normal operating state.
     * After reporting this state, AP will accept VehicleApPowerStateReq#SHUTDOWN_PREPARE.
     * Other power state requests are ignored.
     */
    ON = 0x6,
    /**
     * AP is preparing to shut down. In this state, Garage Mode is active and idle
     * tasks are allowed to run.
     * After reporting this state, AP will accept VehicleApPowerStateReq#SHUTDOWN_PREPARE
     * requesting immediate shutdown or VehicleApPowerStateReq#CANCEL_SHUTDOWN. Other
     * power state requests are ignored.
     */
    SHUTDOWN_PREPARE = 0x7,
    /**
     * AP has stopped preparing to shut down.
     * After reporting this state, AP will accept VehicleApPowerStateReq#ON or
     * VehicleApPowerStateReq#SHUTDOWN_PREPARE. Other power state requests are ignored.
     */
    SHUTDOWN_CANCELLED = 0x8,
};
enum VehicleHwKeyInputAction : int32_t {
    /** Key down */
    ACTION_DOWN = 0,
    /** Key up */
    ACTION_UP = 1,
};
enum VehicleDisplay : int32_t {
    /** The primary Android display (for example, center console) */
    MAIN = 0,
    INSTRUMENT_CLUSTER = 1,
};
/**
 * Units used for int or float type with no attached enum types.
 */
enum VehicleUnit : int32_t {
    SHOULD_NOT_USE      = 0x000,
    METER_PER_SEC       = 0x01,
    RPM                 = 0x02,
    HERTZ               = 0x03,
    PERCENTILE          = 0x10,
    MILLIMETER          = 0x20,
    METER               = 0x21,
    KILOMETER           = 0x23,
    MILE                = 0x24,
    CELSIUS             = 0x30,
    FAHRENHEIT          = 0x31,
    KELVIN              = 0x32,
    MILLILITER          = 0x40,
    LITER               = 0x41,
    /** deprecated. Use US_GALLON instead. */
    GALLON              = 0x42,
    US_GALLON           = 0x42,
    IMPERIAL_GALLON     = 0x43,
    NANO_SECS           = 0x50,
    SECS                = 0x53,
    YEAR                = 0x59,
    // Electrical Units
    WATT_HOUR           = 0x60,
    MILLIAMPERE         = 0x61,
    MILLIVOLT           = 0x62,
    MILLIWATTS          = 0x63,
    AMPERE_HOURS        = 0x64,
    KILOWATT_HOUR       = 0x65,
    KILOPASCAL          = 0x70,
    PSI                 = 0x71,
    BAR                 = 0x72,
    DEGREES             = 0x80,
    MILES_PER_HOUR      = 0x90,
    KILOMETERS_PER_HOUR = 0x91,
};
/**
 * This describes how value of property can change.
 */
enum VehiclePropertyChangeMode : int32_t {
    /**
     * Property of this type must never be changed. Subscription is not supported
     * for these properties.
     */
    STATIC = 0x00,
    /**
     * Properties of this type must report when there is a change.
     * IVehicle#get call must return the current value.
     * Set operation for this property is assumed to be asynchronous. When the
     * property is read (using IVehicle#get) after IVehicle#set, it may still
     * return old value until underlying H/W backing this property has actually
     * changed the state. Once state is changed, the property must dispatch
     * changed value as event.
     */
    ON_CHANGE = 0x01,
    /**
     * Properties of this type change continuously and require a fixed rate of
     * sampling to retrieve the data.  Implementers may choose to send extra
     * notifications on significant value changes.
     */
    CONTINUOUS = 0x02,
};
/**
 * Property config defines the capabilities of it. User of the API
 * must first get the property config to understand the output from get()
 * commands and also to ensure that set() or events commands are in sync with
 * the expected output.
 */
enum VehiclePropertyAccess : int32_t {
    NONE = 0x00,
    READ = 0x01,
    WRITE = 0x02,
    READ_WRITE = 0x03,
};
/**
 * Property status is a dynamic value that may change based on the vehicle state.
 */
enum VehiclePropertyStatus : int32_t {
    /** Property is available and behaving normally */
    AVAILABLE   = 0x00,
    /**
     * A property in this state is not available for reading and writing.  This
     * is a transient state that depends on the availability of the underlying
     * implementation (e.g. hardware or driver). It MUST NOT be used to
     * represent features that this vehicle is always incapable of.  A get() of
     * a property in this state MAY return an undefined value, but MUST
     * correctly describe its status as UNAVAILABLE A set() of a property in
     * this state MAY return NOT_AVAILABLE. The HAL implementation MUST ignore
     * the value of the status field when writing a property value coming from
     * Android.
     */
    UNAVAILABLE = 0x01,
    /** There is an error with this property. */
    ERROR       = 0x02,
};
/**
 * Various gears which can be selected by user and chosen in system.
 */
enum VehicleGear : int32_t {
    GEAR_UNKNOWN = 0x0000,
    GEAR_NEUTRAL = 0x0001,
    GEAR_REVERSE = 0x0002,
    GEAR_PARK = 0x0004,
    GEAR_DRIVE = 0x0008,
    GEAR_1 = 0x0010,
    GEAR_2 = 0x0020,
    GEAR_3 = 0x0040,
    GEAR_4 = 0x0080,
    GEAR_5 = 0x0100,
    GEAR_6 = 0x0200,
    GEAR_7 = 0x0400,
    GEAR_8 = 0x0800,
    GEAR_9 = 0x1000,
};
/**
 * Various Seats in the car.
 */
enum VehicleAreaSeat : int32_t {
    ROW_1_LEFT   = 0x0001,
    ROW_1_CENTER = 0x0002,
    ROW_1_RIGHT  = 0x0004,
    ROW_2_LEFT   = 0x0010,
    ROW_2_CENTER = 0x0020,
    ROW_2_RIGHT  = 0x0040,
    ROW_3_LEFT   = 0x0100,
    ROW_3_CENTER = 0x0200,
    ROW_3_RIGHT  = 0x0400
};
/**
 * Various windshields/windows in the car.
 */
enum VehicleAreaWindow : int32_t {
    FRONT_WINDSHIELD  = 0x00000001,
    REAR_WINDSHIELD   = 0x00000002,
    ROW_1_LEFT        = 0x00000010,
    ROW_1_RIGHT       = 0x00000040,
    ROW_2_LEFT        = 0x00000100,
    ROW_2_RIGHT       = 0x00000400,
    ROW_3_LEFT        = 0x00001000,
    ROW_3_RIGHT       = 0x00004000,
    ROOF_TOP_1        = 0x00010000,
    ROOF_TOP_2        = 0x00020000,
};
enum VehicleAreaDoor : int32_t {
    ROW_1_LEFT = 0x00000001,
    ROW_1_RIGHT = 0x00000004,
    ROW_2_LEFT = 0x00000010,
    ROW_2_RIGHT = 0x00000040,
    ROW_3_LEFT = 0x00000100,
    ROW_3_RIGHT = 0x00000400,
    HOOD = 0x10000000,
    REAR = 0x20000000,
};
enum VehicleAreaMirror : int32_t {
    DRIVER_LEFT = 0x00000001,
    DRIVER_RIGHT = 0x00000002,
    DRIVER_CENTER = 0x00000004,
};
enum VehicleTurnSignal : int32_t {
    NONE = 0x00,
    RIGHT = 0x01,
    LEFT = 0x02,
};
struct VehicleAreaConfig {
    /**
     * Area id is ignored for VehiclePropertyGroup:GLOBAL properties.
     */
    int32_t areaId;
    /**
     * If the property has @data_enum, leave the range to zero.
     *
     * Range will be ignored in the following cases:
     *    - The VehiclePropertyType is not INT32, INT64 or FLOAT.
     *    - Both of min value and max value are zero.
     */
    int32_t minInt32Value;
    int32_t maxInt32Value;
    int64_t minInt64Value;
    int64_t maxInt64Value;
    float minFloatValue;
    float maxFloatValue;
};
struct VehiclePropConfig {
    /** Property identifier */
    int32_t prop;
    /**
     * Defines if the property is read or write or both.
     */
    VehiclePropertyAccess access;
    /**
     * Defines the change mode of the property.
     */
    VehiclePropertyChangeMode changeMode;
    /**
     * Contains per-area configuration.
     */
    vec<VehicleAreaConfig> areaConfigs;
    /** Contains additional configuration parameters */
    vec<int32_t> configArray;
    /**
     * Some properties may require additional information passed over this
     * string. Most properties do not need to set this.
     */
    string configString;
    /**
     * Min sample rate in Hz.
     * Must be defined for VehiclePropertyChangeMode::CONTINUOUS
     */
    float minSampleRate;
    /**
     * Must be defined for VehiclePropertyChangeMode::CONTINUOUS
     * Max sample rate in Hz.
     */
    float maxSampleRate;
};
/**
 * Encapsulates the property name and the associated value. It
 * is used across various API calls to set values, get values or to register for
 * events.
 */
struct VehiclePropValue {
    /** Time is elapsed nanoseconds since boot */
    int64_t timestamp;
    /**
     * Area type(s) for non-global property it must be one of the value from
     * VehicleArea* enums or 0 for global properties.
     */
    int32_t areaId;
    /** Property identifier */
    int32_t prop;
    /** Status of the property */
    VehiclePropertyStatus status;
    /**
     * Contains value for a single property. Depending on property data type of
     * this property (VehiclePropetyType) one field of this structure must be filled in.
     */
    struct RawValue {
        /**
         * This is used for properties of types VehiclePropertyType#INT
         * and VehiclePropertyType#INT_VEC
         */
        vec<int32_t> int32Values;
        /**
         * This is used for properties of types VehiclePropertyType#FLOAT
         * and VehiclePropertyType#FLOAT_VEC
         */
        vec<float> floatValues;
        /** This is used for properties of type VehiclePropertyType#INT64 */
        vec<int64_t> int64Values;
        /** This is used for properties of type VehiclePropertyType#BYTES */
        vec<uint8_t> bytes;
        /** This is used for properties of type VehiclePropertyType#STRING */
        string stringValue;
    };
    RawValue value;
};
enum VehicleIgnitionState : int32_t {
    UNDEFINED = 0,
    /** Steering wheel is locked */
    LOCK = 1,
    /**
     * Steering wheel is not locked, engine and all accessories are OFF. If
     * car can be in LOCK and OFF state at the same time than HAL must report
     * LOCK state.
     */
    OFF,
    /**
     * Typically in this state accessories become available (e.g. radio).
     * Instrument cluster and engine are turned off
     */
    ACC,
    /**
     * Ignition is in state ON. Accessories and instrument cluster available,
     * engine might be running or ready to be started.
     */
    ON,
    /** Typically in this state engine is starting (cranking). */
    START
};
enum SubscribeFlags : int32_t {
    UNDEFINED = 0x0,
    /**
     * Subscribe to event that was originated in vehicle HAL
     * (most likely this event came from the vehicle itself).
     */
    EVENTS_FROM_CAR = 0x1,
    /**
     * Use this flag to subscribe on events when IVehicle#set(...) was called by
     * vehicle HAL's client (e.g. Car Service).
     */
    EVENTS_FROM_ANDROID = 0x2,
};
/**
 * Encapsulates information about subscription to vehicle property events.
 */
struct SubscribeOptions {
    /** Property to subscribe */
    int32_t propId;
    /**
     * Sample rate in Hz.
     *
     * Must be provided for properties with
     * VehiclePropertyChangeMode::CONTINUOUS. The value must be within
     * VehiclePropConfig#minSamplingRate .. VehiclePropConfig#maxSamplingRate
     * for a given property.
     * This value indicates how many updates per second client wants to receive.
     */
    float sampleRate;
    /** Flags that indicate to which event sources to listen. */
    SubscribeFlags flags;
};
/** Error codes used in vehicle HAL interface. */
enum StatusCode : int32_t {
    OK = 0,
    /** Try again. */
    TRY_AGAIN = 1,
    /** Invalid argument provided. */
    INVALID_ARG = 2,
    /**
     * This code must be returned when device that associated with the vehicle
     * property is not available. For example, when client tries to set HVAC
     * temperature when the whole HVAC unit is turned OFF.
     */
    NOT_AVAILABLE = 3,
    /** Access denied */
    ACCESS_DENIED = 4,
    /** Something unexpected has happened in Vehicle HAL */
    INTERNAL_ERROR = 5,
};
enum VehicleAreaWheel : int32_t {
    UNKNOWN = 0x0,
    LEFT_FRONT = 0x1,
    RIGHT_FRONT = 0x2,
    LEFT_REAR = 0x4,
    RIGHT_REAR = 0x8,
};
/**
 * The status of the vehicle's fuel system.
 * These values come from the SAE J1979 standard.
 */
enum Obd2FuelSystemStatus : int32_t {
    OPEN_INSUFFICIENT_ENGINE_TEMPERATURE = 1,
    CLOSED_LOOP = 2,
    OPEN_ENGINE_LOAD_OR_DECELERATION = 4,
    OPEN_SYSTEM_FAILURE = 8,
    CLOSED_LOOP_BUT_FEEDBACK_FAULT = 16,
};
/** Defines which ignition monitors are available to be read. */
enum Obd2IgnitionMonitorKind : int32_t {
    SPARK = 0,
    COMPRESSION = 1,
};
/**
 * Ignition monitors common to both SPARK and COMPRESSION.
 * These values come from the SAE J1979 standard.
 */
enum Obd2CommonIgnitionMonitors : int32_t {
    COMPONENTS_AVAILABLE = 0x1 << 0,
    COMPONENTS_INCOMPLETE = 0x1 << 1,
    FUEL_SYSTEM_AVAILABLE = 0x1 << 2,
    FUEL_SYSTEM_INCOMPLETE = 0x1 << 3,
    MISFIRE_AVAILABLE = 0x1 << 4,
    MISFIRE_INCOMPLETE = 0x1 << 5,
};
/**
 * Ignition monitors available for SPARK vehicles.
 * These values come from the SAE J1979 standard.
 */
enum Obd2SparkIgnitionMonitors : Obd2CommonIgnitionMonitors {
    EGR_AVAILABLE = 0x1 << 6,
    EGR_INCOMPLETE = 0x1 << 7,
    OXYGEN_SENSOR_HEATER_AVAILABLE = 0x1 << 8,
    OXYGEN_SENSOR_HEATER_INCOMPLETE = 0x1 << 9,
    OXYGEN_SENSOR_AVAILABLE = 0x1 << 10,
    OXYGEN_SENSOR_INCOMPLETE = 0x1 << 11,
    AC_REFRIGERANT_AVAILABLE = 0x1 << 12,
    AC_REFRIGERANT_INCOMPLETE = 0x1 << 13,
    SECONDARY_AIR_SYSTEM_AVAILABLE = 0x1 << 14,
    SECONDARY_AIR_SYSTEM_INCOMPLETE = 0x1 << 15,
    EVAPORATIVE_SYSTEM_AVAILABLE = 0x1 << 16,
    EVAPORATIVE_SYSTEM_INCOMPLETE = 0x1 << 17,
    HEATED_CATALYST_AVAILABLE = 0x1 << 18,
    HEATED_CATALYST_INCOMPLETE = 0x1 << 19,
    CATALYST_AVAILABLE = 0x1 << 20,
    CATALYST_INCOMPLETE = 0x1 << 21,
};
/**
 * Ignition monitors only available for COMPRESSION vehicles.
 * These values come from the SAE J1979 standard.
 */
enum Obd2CompressionIgnitionMonitors : Obd2CommonIgnitionMonitors {
    EGR_OR_VVT_AVAILABLE = 0x1 << 6,
    EGR_OR_VVT_INCOMPLETE = 0x1 << 7,
    PM_FILTER_AVAILABLE = 0x1 << 8,
    PM_FILTER_INCOMPLETE = 0x1 << 9,
    EXHAUST_GAS_SENSOR_AVAILABLE = 0x1 << 10,
    EXHAUST_GAS_SENSOR_INCOMPLETE = 0x1 << 11,
    BOOST_PRESSURE_AVAILABLE = 0x1 << 12,
    BOOST_PRESSURE_INCOMPLETE = 0x1 << 13,
    NOx_SCR_AVAILABLE = 0x1 << 14,
    NOx_SCR_INCOMPLETE = 0x1 << 15,
    NMHC_CATALYST_AVAILABLE = 0x1 << 16,
    NMHC_CATALYST_INCOMPLETE = 0x1 << 17,
};
/**
 * The status of the vehicle's secondary air system.
 * These values come from the SAE J1979 standard.
 */
enum Obd2SecondaryAirStatus : int32_t {
    UPSTREAM = 1,
    DOWNSTREAM_OF_CATALYCIC_CONVERTER = 2,
    FROM_OUTSIDE_OR_OFF = 4,
    PUMP_ON_FOR_DIAGNOSTICS = 8,
};
/**
 * The fuel type(s) supported by a vehicle.
 * These values come from the SAE J1979 standard.
 */
enum Obd2FuelType : int32_t {
    NOT_AVAILABLE = 0,
    GASOLINE = 1,
    METHANOL = 2,
    ETHANOL = 3,
    DIESEL = 4,
    LPG = 5,
    CNG = 6,
    PROPANE = 7,
    ELECTRIC = 8,
    BIFUEL_RUNNING_GASOLINE = 9,
    BIFUEL_RUNNING_METHANOL = 10,
    BIFUEL_RUNNING_ETHANOL = 11,
    BIFUEL_RUNNING_LPG = 12,
    BIFUEL_RUNNING_CNG = 13,
    BIFUEL_RUNNING_PROPANE = 14,
    BIFUEL_RUNNING_ELECTRIC = 15,
    BIFUEL_RUNNING_ELECTRIC_AND_COMBUSTION = 16,
    HYBRID_GASOLINE = 17,
    HYBRID_ETHANOL = 18,
    HYBRID_DIESEL = 19,
    HYBRID_ELECTRIC = 20,
    HYBRID_RUNNING_ELECTRIC_AND_COMBUSTION = 21,
    HYBRID_REGENERATIVE = 22,
    BIFUEL_RUNNING_DIESEL = 23,
};
/**
 * This enum provides the canonical mapping for sensor properties that have an integer value.
 * The ordering of the values is taken from the OBD2 specification.
 * Some of the properties are represented as an integer mapping to another enum. In those cases
 * expect a comment by the property definition describing the enum to look at for the mapping.
 * Any value greater than the last reserved index is available to vendors to map their extensions.
 * While these values do not directly map to SAE J1979 PIDs, an equivalence is listed next
 * to each one to aid implementors.
 */
enum DiagnosticIntegerSensorIndex : int32_t {
    /** refer to FuelSystemStatus for a description of this value. */
    FUEL_SYSTEM_STATUS = 0, /* PID 0x03 */
    MALFUNCTION_INDICATOR_LIGHT_ON = 1, /* PID 0x01 */
    /** refer to IgnitionMonitorKind for a description of this value. */
    IGNITION_MONITORS_SUPPORTED = 2, /* PID 0x01 */
    /**
     * The value of this sensor is a bitmask that specifies whether ignition-specific
     * tests are available and whether they are complete. The semantics of the individual
     * bits in this value are given by, respectively, SparkIgnitionMonitors and
     * CompressionIgnitionMonitors depending on the value of IGNITION_MONITORS_SUPPORTED.
     */
    IGNITION_SPECIFIC_MONITORS = 3, /* PID 0x01 */
    INTAKE_AIR_TEMPERATURE = 4, /* PID 0x0F */
    /** refer to SecondaryAirStatus for a description of this value. */
    COMMANDED_SECONDARY_AIR_STATUS = 5, /* PID 0x12 */
    NUM_OXYGEN_SENSORS_PRESENT = 6, /* PID 0x13 */
    RUNTIME_SINCE_ENGINE_START = 7, /* PID 0x1F */
    DISTANCE_TRAVELED_WITH_MALFUNCTION_INDICATOR_LIGHT_ON = 8, /* PID 0x21 */
    WARMUPS_SINCE_CODES_CLEARED = 9, /* PID 0x30 */
    DISTANCE_TRAVELED_SINCE_CODES_CLEARED = 10, /* PID 0x31 */
    ABSOLUTE_BAROMETRIC_PRESSURE = 11, /* PID 0x33 */
    CONTROL_MODULE_VOLTAGE = 12, /* PID 0x42 */
    AMBIENT_AIR_TEMPERATURE = 13, /* PID 0x46 */
    TIME_WITH_MALFUNCTION_LIGHT_ON = 14, /* PID 0x4D */
    TIME_SINCE_TROUBLE_CODES_CLEARED = 15, /* PID 0x4E */
    MAX_FUEL_AIR_EQUIVALENCE_RATIO = 16, /* PID 0x4F */
    MAX_OXYGEN_SENSOR_VOLTAGE = 17, /* PID 0x4F */
    MAX_OXYGEN_SENSOR_CURRENT = 18, /* PID 0x4F */
    MAX_INTAKE_MANIFOLD_ABSOLUTE_PRESSURE = 19, /* PID 0x4F */
    MAX_AIR_FLOW_RATE_FROM_MASS_AIR_FLOW_SENSOR = 20, /* PID 0x50 */
    /** refer to FuelType for a description of this value. */
    FUEL_TYPE = 21, /* PID 0x51 */
    FUEL_RAIL_ABSOLUTE_PRESSURE = 22, /* PID 0x59 */
    ENGINE_OIL_TEMPERATURE = 23, /* PID 0x5C */
    DRIVER_DEMAND_PERCENT_TORQUE = 24, /* PID 0x61 */
    ENGINE_ACTUAL_PERCENT_TORQUE = 25, /* PID 0x62 */
    ENGINE_REFERENCE_PERCENT_TORQUE = 26, /* PID 0x63 */
    ENGINE_PERCENT_TORQUE_DATA_IDLE = 27, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT1 = 28, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT2 = 29, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT3 = 30, /* PID 0x64 */
    ENGINE_PERCENT_TORQUE_DATA_POINT4 = 31, /* PID 0x64 */
    LAST_SYSTEM_INDEX = ENGINE_PERCENT_TORQUE_DATA_POINT4,
};
/**
 * This enum provides the canonical mapping for sensor properties that have a floating-point value.
 * The ordering of the values is taken from the OBD2 specification.
 * Any value greater than the last reserved index is available to vendors to map their extensions.
 * While these values do not directly map to SAE J1979 PIDs, an equivalence is listed next
 * to each one to aid implementors.
 */
enum DiagnosticFloatSensorIndex : int32_t {
    CALCULATED_ENGINE_LOAD = 0, /* PID 0x04 */
    ENGINE_COOLANT_TEMPERATURE = 1, /* PID 0x05 */
    SHORT_TERM_FUEL_TRIM_BANK1 = 2, /* PID 0x06 */
    LONG_TERM_FUEL_TRIM_BANK1 = 3, /* PID 0x07 */
    SHORT_TERM_FUEL_TRIM_BANK2 = 4, /* PID 0x08 */
    LONG_TERM_FUEL_TRIM_BANK2 = 5, /* PID 0x09 */
    FUEL_PRESSURE = 6, /* PID 0x0A */
    INTAKE_MANIFOLD_ABSOLUTE_PRESSURE = 7, /* PID 0x0B */
    ENGINE_RPM = 8, /* PID 0x0C */
    VEHICLE_SPEED = 9, /* PID 0x0D */
    TIMING_ADVANCE = 10, /* PID 0x0E */
    MAF_AIR_FLOW_RATE = 11, /* PID 0x10 */
    THROTTLE_POSITION = 12, /* PID 0x11 */
    OXYGEN_SENSOR1_VOLTAGE = 13, /* PID 0x14 */
    OXYGEN_SENSOR1_SHORT_TERM_FUEL_TRIM = 14, /* PID 0x14 */
    OXYGEN_SENSOR1_FUEL_AIR_EQUIVALENCE_RATIO = 15, /* PID 0x24 */
    OXYGEN_SENSOR2_VOLTAGE = 16, /* PID 0x15 */
    OXYGEN_SENSOR2_SHORT_TERM_FUEL_TRIM = 17, /* PID 0x15 */
    OXYGEN_SENSOR2_FUEL_AIR_EQUIVALENCE_RATIO = 18, /* PID 0x25 */
    OXYGEN_SENSOR3_VOLTAGE = 19, /* PID 0x16 */
    OXYGEN_SENSOR3_SHORT_TERM_FUEL_TRIM = 20, /* PID 0x16 */
    OXYGEN_SENSOR3_FUEL_AIR_EQUIVALENCE_RATIO = 21, /* PID 0x26 */
    OXYGEN_SENSOR4_VOLTAGE = 22, /* PID 0x17 */
    OXYGEN_SENSOR4_SHORT_TERM_FUEL_TRIM = 23, /* PID 0x17 */
    OXYGEN_SENSOR4_FUEL_AIR_EQUIVALENCE_RATIO = 24, /* PID 0x27 */
    OXYGEN_SENSOR5_VOLTAGE = 25, /* PID 0x18 */
    OXYGEN_SENSOR5_SHORT_TERM_FUEL_TRIM = 26, /* PID 0x18 */
    OXYGEN_SENSOR5_FUEL_AIR_EQUIVALENCE_RATIO = 27, /* PID 0x28 */
    OXYGEN_SENSOR6_VOLTAGE = 28, /* PID 0x19 */
    OXYGEN_SENSOR6_SHORT_TERM_FUEL_TRIM = 29, /* PID 0x19 */
    OXYGEN_SENSOR6_FUEL_AIR_EQUIVALENCE_RATIO = 30, /* PID 0x29 */
    OXYGEN_SENSOR7_VOLTAGE = 31, /* PID 0x1A */
    OXYGEN_SENSOR7_SHORT_TERM_FUEL_TRIM = 32, /* PID 0x1A */
    OXYGEN_SENSOR7_FUEL_AIR_EQUIVALENCE_RATIO = 33, /* PID 0x2A */
    OXYGEN_SENSOR8_VOLTAGE = 34, /* PID 0x1B */
    OXYGEN_SENSOR8_SHORT_TERM_FUEL_TRIM = 35, /* PID 0x1B */
    OXYGEN_SENSOR8_FUEL_AIR_EQUIVALENCE_RATIO = 36, /* PID 0x2B */
    FUEL_RAIL_PRESSURE = 37, /* PID 0x22 */
    FUEL_RAIL_GAUGE_PRESSURE = 38, /* PID 0x23 */
    COMMANDED_EXHAUST_GAS_RECIRCULATION = 39, /* PID 0x2C */
    EXHAUST_GAS_RECIRCULATION_ERROR = 40, /* PID 0x2D */
    COMMANDED_EVAPORATIVE_PURGE = 41, /* PID 0x2E */
    FUEL_TANK_LEVEL_INPUT = 42, /* PID 0x2F */
    EVAPORATION_SYSTEM_VAPOR_PRESSURE = 43, /* PID 0x32 */
    CATALYST_TEMPERATURE_BANK1_SENSOR1 = 44, /* PID 0x3C */
    CATALYST_TEMPERATURE_BANK2_SENSOR1 = 45, /* PID 0x3D */
    CATALYST_TEMPERATURE_BANK1_SENSOR2 = 46, /* PID 0x3E */
    CATALYST_TEMPERATURE_BANK2_SENSOR2 = 47, /* PID 0x3F */
    ABSOLUTE_LOAD_VALUE = 48, /* PID 0x43 */
    FUEL_AIR_COMMANDED_EQUIVALENCE_RATIO = 49, /* PID 0x44 */
    RELATIVE_THROTTLE_POSITION = 50, /* PID 0x45 */
    ABSOLUTE_THROTTLE_POSITION_B = 51, /* PID 0x47 */
    ABSOLUTE_THROTTLE_POSITION_C = 52, /* PID 0x48 */
    ACCELERATOR_PEDAL_POSITION_D = 53, /* PID 0x49 */
    ACCELERATOR_PEDAL_POSITION_E = 54, /* PID 0x4A */
    ACCELERATOR_PEDAL_POSITION_F = 55, /* PID 0x4B */
    COMMANDED_THROTTLE_ACTUATOR = 56, /* PID 0x4C */
    ETHANOL_FUEL_PERCENTAGE = 57, /* PID 0x52 */
    ABSOLUTE_EVAPORATION_SYSTEM_VAPOR_PRESSURE = 58, /* PID 0x53 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK1 = 59, /* PID 0x55 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK2 = 60, /* PID 0x57 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK3 = 61, /* PID 0x55 */
    SHORT_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK4 = 62, /* PID 0x57 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK1 = 63, /* PID 0x56 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK2 = 64, /* PID 0x58 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK3 = 65, /* PID 0x56 */
    LONG_TERM_SECONDARY_OXYGEN_SENSOR_TRIM_BANK4 = 66, /* PID 0x58 */
    RELATIVE_ACCELERATOR_PEDAL_POSITION = 67, /* PID 0x5A */
    HYBRID_BATTERY_PACK_REMAINING_LIFE = 68, /* PID 0x5B */
    FUEL_INJECTION_TIMING = 69, /* PID 0x5D */
    ENGINE_FUEL_RATE = 70, /* PID 0x5E */
    LAST_SYSTEM_INDEX = ENGINE_FUEL_RATE,
};
/**
 * This enum lists the types of supported VMS messages. It is used as the first
 * integer in the vehicle property integers array and determines how the rest of
 * the message is decoded.
 */
enum VmsMessageType : int32_t {
    /**
     * A request from the subscribers to the VMS service to subscribe to a layer.
     *
     * This message type uses enum VmsMessageWithLayerIntegerValuesIndex.
     */
    SUBSCRIBE = 1,
    /**
     * A request from the subscribers to the VMS service to subscribe to a layer from a specific publisher.
     *
     * This message type uses enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex.
     */
    SUBSCRIBE_TO_PUBLISHER = 2,
    /**
     * A request from the subscribers to the VMS service to unsubscribes from a layer.
     *
     * This message type uses enum VmsMessageWithLayerIntegerValuesIndex.
     */
    UNSUBSCRIBE = 3,
    /**
     * A request from the subscribers to the VMS service to unsubscribes from a layer from a specific publisher.
     *
     * This message type uses enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex.
     */
    UNSUBSCRIBE_TO_PUBLISHER = 4,
    /**
     * Information from the publishers to the VMS service about the layers which the client can publish.
     *
     * This message type uses enum VmsOfferingMessageIntegerValuesIndex.
     */
    OFFERING = 5,
    /**
     * A request from the subscribers to the VMS service to get the available layers.
     *
     * This message type uses enum VmsBaseMessageIntegerValuesIndex.
     */
    AVAILABILITY_REQUEST = 6,
    /**
     * A request from the publishers to the VMS service to get the layers with subscribers.
     *
     * This message type uses enum VmsBaseMessageIntegerValuesIndex.
     */
    SUBSCRIPTIONS_REQUEST = 7,
    /**
     * A response from the VMS service to the subscribers to a VmsMessageType.AVAILABILITY_REQUEST
     *
     * This message type uses enum VmsAvailabilityStateIntegerValuesIndex.
     */
    AVAILABILITY_RESPONSE = 8,
    /**
     * A notification from the VMS service to the subscribers on a change in the available layers.
     *
     * This message type uses enum VmsAvailabilityStateIntegerValuesIndex.
     */
    AVAILABILITY_CHANGE = 9,
    /**
     * A response from the VMS service to the publishers to a VmsMessageType.SUBSCRIPTIONS_REQUEST
     *
     * This message type uses enum VmsSubscriptionsStateIntegerValuesIndex.
     */
    SUBSCRIPTIONS_RESPONSE = 10,
    /**
     * A notification from the VMS service to the publishers on a change in the layers with subscribers.
     *
     * This message type uses enum VmsSubscriptionsStateIntegerValuesIndex.
     */
    SUBSCRIPTIONS_CHANGE = 11,
    /**
     * A message from the VMS service to the subscribers or from the publishers to the VMS service
     * with a serialized VMS data packet as defined in the VMS protocol.
     *
     * This message type uses enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex.
     */
    DATA = 12,
    /**
     * A request from the publishers to the VMS service to get a Publisher ID for a serialized VMS
     * provider description packet as defined in the VMS protocol.
     *
     * This message type uses enum VmsBaseMessageIntegerValuesIndex.
     */
    PUBLISHER_ID_REQUEST = 13,
    /**
     * A response from the VMS service to the publisher that contains a provider description packet
     * and the publisher ID assigned to it.
     *
     * This message type uses enum VmsPublisherInformationIntegerValuesIndex.
     */
    PUBLISHER_ID_RESPONSE = 14,
    /**
     * A request from the subscribers to the VMS service to get information for a Publisher ID.
     *
     * This message type uses enum VmsPublisherInformationIntegerValuesIndex.
     */
    PUBLISHER_INFORMATION_REQUEST = 15,
    /**
     * A response from the VMS service to the subscribers that contains a provider description packet
     * and the publisher ID assigned to it.
     *
     * This message type uses enum VmsPublisherInformationIntegerValuesIndex.
     */
    PUBLISHER_INFORMATION_RESPONSE = 16,
    /**
     * A notification indicating that the sender has been reset.
     *
     * The receiving party must reset its internal state and respond to the
     * sender with a START_SESSION message as acknowledgement.
     *
     * This message type uses enum VmsStartSessionMessageIntegerValuesIndex.
     */
    START_SESSION = 17,
    LAST_VMS_MESSAGE_TYPE = START_SESSION,
};
/**
 * Every VMS message starts with the type of the message from the VmsMessageType enum.
 * Messages with no parameters such as VmsMessageType.AVAILABILITY_REQUEST,
 * VmsMessageType.SUBSCRIPTIONS_REQUEST and VmsMessageType.DATA are also based on this enum.
 */
enum VmsBaseMessageIntegerValuesIndex : int32_t {
    /* The message type as enumerated by VmsMessageType enum. */
    MESSAGE_TYPE = 0,
};
/*
 * Handshake data sent as part of a VmsMessageType.START_SESSION message.
 *
 * A new session is initiated by sending a START_SESSION message with the
 * sender's identifier populated and the receiver's identifier set to -1.
 *
 * Identifier values are independently generated, but must be non-negative, and
 * increase monotonically between reboots.
 *
 * Upon receiving a START_SESSION with a mis-matching identifier, the receiver
 * must clear any cached VMS offering or subscription state and acknowledge the
 * new session by responding with a START_SESSION message that populates both
 * identifier fields.
 *
 * Any VMS messages received between initiation and completion of the handshake
 * must be discarded.
 */
enum VmsStartSessionMessageIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    /* Identifier field for the Android system service. */
    SERVICE_ID = 1,
    /* Identifier field for the HAL client process. */
    CLIENT_ID = 2,
};
/*
 * A VMS message with a layer is sent as part of a VmsMessageType.SUBSCRIBE or
 * VmsMessageType.UNSUBSCRIBE messages.
 *
 * The layer type is defined in the VMS protocol, and the subtype and version are
 * controlled by the implementer of the publisher.
 */
enum VmsMessageWithLayerIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    LAYER_TYPE = 1,
    LAYER_SUBTYPE = 2,
    LAYER_VERSION = 3,
};
/*
 * A VMS message with a layer and publisher ID is sent as part of a
 * VmsMessageType.SUBSCRIBE_TO_PUBLISHER, VmsMessageType.UNSUBSCRIBE_TO_PUBLISHER messages and
 * VmsMessageType.DATA .
 */
enum VmsMessageWithLayerAndPublisherIdIntegerValuesIndex : VmsMessageWithLayerIntegerValuesIndex {
    PUBLISHER_ID = 4,
};
/*
 * An offering can be sent by publishers as part of VmsMessageType.OFFERING in order to
 * advertise which layers they can publish and under which constraints: e.g., I can publish Layer X
 * if someone else will publish Layer Y.
 * The offering contains the publisher ID which was assigned to the publisher by the VMS service.
 * A single offering is represented as:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of dependencies (N)
 * - N x (Layer type, Layer subtype, Layer version)
 */
enum VmsOfferingMessageIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    PUBLISHER_ID = 1,
    NUMBER_OF_OFFERS = 2,
    OFFERING_START = 3,
};
/**
 * A subscriptions state is sent to the publishers in response to a change in the subscriptions
 * as part of a VmsMessageType.SUBSCRIPTIONS_CHANGE, or in response to a
 * VmsMessageType.SUBSCRIPTIONS_REQUEST message as part of VmsMessageType.SUBSCRIPTIONS_RESPONSE.
 * The VMS service issues monotonically increasing sequence numbers, and in case a subscriber receives
 * a smaller sequnce number it should ignore the message.
 * The subscriptions are sent as a list of layers followed by a list of associated layers:
 * {Sequence number, N, M, N x layer, M x associated layer}
 * A subscribed layer is represented as three integers:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * A subscribed associated layer is a layer with a list of publisher IDs. It is represented as:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of publisher IDs (N)
 * - N x publisher ID
 */
enum VmsSubscriptionsStateIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    SEQUENCE_NUMBER = 1,
    NUMBER_OF_LAYERS = 2,
    NUMBER_OF_ASSOCIATED_LAYERS = 3,
    SUBSCRIPTIONS_START = 4,
};
/**
 * An availability state is sent to the subscribers in response to a change in the available
 * layers as part of a VmsMessageType.AVAILABILITY_CHANGE message, or in response to a
 * VmsMessageType.AVAILABILITY_REQUEST message as part of a VmsMessageType.AVAILABILITY_RESPONSE.
 * The VMS service issues monotonically increasing sequence numbers, and in case a subscriber receives
 * a smaller sequnce number, it should ignore the message.
 * An available associated layer is a layer with a list of publisher IDs:
 * - Layer type
 * - Layer subtype
 * - Layer version
 * - Number of publisher IDs (N)
 * - N x publisher ID
 */
enum VmsAvailabilityStateIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    SEQUENCE_NUMBER = 1,
    NUMBER_OF_ASSOCIATED_LAYERS = 2,
    LAYERS_START = 3,
};
/*
 * Publishers send the VMS service their information and assigned in response a publisher ID.
 * Subscribers can request the publisher information for a publisher ID they received in other messages.
 */
enum VmsPublisherInformationIntegerValuesIndex : VmsBaseMessageIntegerValuesIndex {
    PUBLISHER_ID = 1,
};
/**
 * Information about a specific Android user.
 */
struct UserInfo {
    UserId userId;
    UserFlags flags;
};
/**
 * Id of an Android user.
 *
 * Must be > 0 for valid ids, or -10000 (which is the same as Android.UserHandle.USER_NULL) when
 * it's not used.
 */
typedef int32_t UserId;
/**
 * Flags used to define the characteristics of an Android user.
 */
enum UserFlags: int32_t {
    /**
     * No flags.
     */
    NONE = 0x0,
    /**
     * System user.
     * On automotive, that user is always running, although never on foreground (except during
     * boot or exceptional circumstances).
     */
    SYSTEM = 0x01,
    /**
     * Guest users have restrictions.
     */
    GUEST = 0x02,
    /**
     * Ephemeral users have non-persistent state.
     */
    EPHEMERAL = 0x04,
    /**
     * Admin users have additional privileges such as permission to create other users.
     */
    ADMIN = 0x08,
    /**
     * Disabled users are marked for deletion.
     */
    DISABLED = 0x10,
     /**
     * Profile user is a profile of another user.
     */
    PROFILE = 0x20,
};
/**
 * Information about all Android users.
 *
 * NOTE: this struct is not used in the HAL properties directly, it's part of other structs, which
 * in turn are converted to a VehiclePropValue.RawValue through libraries provided by the default
 * Vehicle HAL implementation.
 */
struct UsersInfo {
    /** The current foreground user. */
    UserInfo currentUser;
    /**
     * Number of existing users; includes the current user, recently removed users (with DISABLED
     * flag), and profile users (with PROFILE flag).
     */
    int32_t numberUsers;
    /**
     * List of existing users; includes the current user, recently removed users (with DISABLED
     * flag), and profile users (with PROFILE flag).
     */
    vec<UserInfo> existingUsers;
 };
/**
 * Id of a request related to user management.
 *
 * This id can be used by the Android system to map responses sent by the HAL, and vice-versa.
 *
 * For requests originated by Android, the value is positive (> 0), while for requests originated by
 * the HAL it must be negative (< 0).
 */
typedef int32_t UserRequestId;
/**
 * Defines the format of a INITIAL_USER_INFO request made by the Android system.
 *
 * NOTE: this struct is not used in the HAL properties directly, it must be converted to
 * VehiclePropValue.RawValue through libraries provided by the default Vehicle HAL implementation.
 */
struct InitialUserInfoRequest {
    /**
     * Arbitrary id used to map the HAL response to the request.
     */
    UserRequestId requestId;
    /**
     * Type of request.
     */
    InitialUserInfoRequestType requestType;
    /**
     * Information about the current state of the Android system.
     */
    UsersInfo usersInfo;
};
/**
 * Defines when a INITIAL_USER_INFO request was made.
 */
enum InitialUserInfoRequestType : int32_t {
  /** At the first time Android was booted (or after a factory reset). */
  FIRST_BOOT = 1,
  /** At the first time Android was booted after the system was updated. */
  FIRST_BOOT_AFTER_OTA = 2,
  /** When Android was booted "from scratch". */
  COLD_BOOT = 3,
  /** When Android was resumed after the system was suspended to memory. */
  RESUME = 4,
};
/**
 * Defines the format of a HAL response to a INITIAL_USER_INFO request.
 *
 * NOTE: this struct is not used in the HAL properties directly, it must be converted to
 * VehiclePropValue.RawValue through libraries provided by the default Vehicle HAL implementation.
 */
struct InitialUserInfoResponse {
    /**
     * Id of the request being responded.
     */
    UserRequestId requestId;
    /**
     * which action the Android system should take.
     */
    InitialUserInfoResponseAction action;
    /**
     * Information about the user that should be switched to or created.
     */
    UserInfo userToSwitchOrCreate;
    /**
     * System locales of the initial user (value will be passed as-is to
     * android.provider.Settings.System.SYSTEM_LOCALES)
     */
    string userLocales;
    /**
     * Name of the user that should be created.
     */
    string userNameToCreate;
};
/**
 * Defines which action the Android system should take in an INITIAL_USER_INFO request.
 */
enum InitialUserInfoResponseAction : int32_t {
   /**
    * Let the Android System decide what to do.
    *
    * For example, it might create a new user on first boot, and switch to the last
    * active user afterwards.
    */
   DEFAULT = 0,
   /**
    * Switch to an existing Android user.
    */
   SWITCH = 1,
   /**
    * Create a new Android user (and switch to it).
    */
   CREATE = 2,
};
/**
 * Defines the format of a SWITCH_USER property.
 *
 * NOTE: this struct is not used in the HAL properties directly, it must be converted to
 * VehiclePropValue.RawValue through libraries provided by the default Vehicle HAL implementation.
 */
struct SwitchUserRequest {
    /**
     * Arbitrary id used to map the response to the request.
     */
    UserRequestId requestId;
    /**
     * Type of message.
     */
    SwitchUserMessageType messageType;
    /**
     * Information about the Android user being switched to.
     *
     * Only the user id (but not the flags) should be set when the request is made by HAL.
     */
    UserInfo targetUser;
    /**
     * Information about the current state of the Android system.
     *
     * Should not be set when the request is made by HAL.
     */
    UsersInfo usersInfo;
};
/**
 * Defines the reason a SWITCH_USER call was made.
 *
 * The meaning of each constant is explained in that property.
 */
enum SwitchUserMessageType: int32_t {
   LEGACY_ANDROID_SWITCH = 1,
   ANDROID_SWITCH = 2,
   VEHICLE_RESPONSE = 3,
   VEHICLE_REQUEST = 4,
   ANDROID_POST_SWITCH = 5,
};
/**
 * Defines the result of a SwitchUserRequest.
 *
 * NOTE: this struct is not used in the HAL properties directly, it must be converted to
 * VehiclePropValue.RawValue through libraries provided by the default Vehicle HAL implementation.
 */
struct SwitchUserResponse {
    /**
     * Id of the request being responded.
     */
    UserRequestId requestId;
    /**
     * Type of message.
     */
    SwitchUserMessageType messageType;
    /**
     * Status of the request.
     */
    SwitchUserStatus status;
    /**
     * HAL-specific error message.
     *
     * This argument is optional, and when defined, it's passed "as-is" to the caller. It could be
     * used to show custom error messages to the end user.
     */
    string errorMessage;
};
/**
 * Status of the response to a SwitchUserRequest.
 */
enum SwitchUserStatus : int32_t {
   /** The request succeeded and the HAL user was switched. */
   SUCCESS = 1,
   /** The request failed and the HAL user remained the same. */
   FAILURE = 2,
};
/**
 * Defines the format of a CREATE_USER property.
 *
 * NOTE: this struct is not used in the HAL properties directly, it must be converted to
 * VehiclePropValue.RawValue through libraries provided by the default Vehicle HAL implementation.
 */
struct CreateUserRequest {
    /**
     * Arbitrary id used to map the response to the request.
     */
    UserRequestId requestId;
    /**
     * Basic information about Android user that was created.
     */
    UserInfo newUserInfo;
    /**
     * Name of the new Android user.
     */
     string newUserName;
    /**
     * Information about the current state of the Android system.
     */
    UsersInfo usersInfo;
};
/**
 * Defines the result of a CreateUserRequest.
 *
 * NOTE: this struct is not used in the HAL properties directly, it must be converted to
 * VehiclePropValue.RawValue through libraries provided by the default Vehicle HAL implementation.
 */
struct CreateUserResponse {
    /**
     * Id of the request being responded.
     */
    UserRequestId requestId;
    /**
     * Status of the request.
     */
    CreateUserStatus status;
    /**
     * HAL-specific error message.
     *
     * This argument is optional, and when defined, it's passed "as-is" to the caller. It could be
     * used to show custom error messages to the end user.
     */
    string errorMessage;
};
/**
 * Status of the response to a CreateUserRequest.
 */
enum CreateUserStatus : int32_t {
   /**
    * The request succeeded (for example, HAL created a new internal user, or associated the
    * Android user to an existing internal user).
    */
   SUCCESS = 1,
   /**
     * The request failed (and Android will remove the Android user).
     */
   FAILURE = 2,
};
/**
 * Defines the format of a REMOVE_USER property.
 *
 * NOTE: this struct is not used in the HAL properties directly, it must be converted to
 * VehiclePropValue.RawValue through libraries provided by the default Vehicle HAL implementation.
 */
struct RemoveUserRequest {
    /**
     * Arbitrary id used to map the response to the request.
     */
    UserRequestId requestId;
    /**
     * Information about the Android user that was removed.
     */
    UserInfo removedUserInfo;
    /**
     * Information about the current state of the Android system.
     */
    UsersInfo usersInfo;
};
/**
  * Types of mechanisms used to identify an Android user.
  *
  * See USER_IDENTIFICATION_ASSOCIATION for more details and example.
  */
enum UserIdentificationAssociationType: int32_t {
   /** Key used to unlock the car. */
   KEY_FOB = 1,
   /** Custom mechanism defined by the OEM. */
   CUSTOM_1 = 101,
   /** Custom mechanism defined by the OEM. */
   CUSTOM_2 = 102,
   /** Custom mechanism defined by the OEM. */
   CUSTOM_3 = 103,
   /** Custom mechanism defined by the OEM. */
   CUSTOM_4 = 104,
};
/**
 * Whether a UserIdentificationAssociationType is associate with an Android user.
 */
enum UserIdentificationAssociationValue : int32_t {
   /**
    * Used when the status of an association could not be determined.
    *
    * For example, in a set() request, it would indicate a failure to set the given type.
    */
   UNKNOWN = 1,
   /**
    * The identification type is associated with the current foreground Android user.
    */
   ASSOCIATED_CURRENT_USER = 2,
   /**
    * The identification type is associated with another Android user.
    */
   ASSOCIATED_ANOTHER_USER = 3,
   /**
    * The identification type is not associated with any Android user.
    */
   NOT_ASSOCIATED_ANY_USER = 4,
};
/**
 * Used to set a UserIdentificationAssociationType with an Android user.
 */
enum UserIdentificationAssociationSetValue : int32_t {
   /**
    * Associate the identification type with the current foreground Android user.
    */
   ASSOCIATE_CURRENT_USER = 1,
   /**
    * Disassociate the identification type from the current foreground Android user.
    */
   DISASSOCIATE_CURRENT_USER = 2,
   /**
    * Disassociate the identification type from all Android users.
    */
   DISASSOCIATE_ALL_USERS = 3,
};
/**
 * Defines the format of a get() call to USER_IDENTIFICATION_ASSOCIATION.
 *
 * NOTE: this struct is not used in the HAL properties directly, it must be converted to
 * VehiclePropValue.RawValue through libraries provided by the default Vehicle HAL implementation.
 */
struct UserIdentificationGetRequest {
    /**
     * Id of the request being responded.
     */
    UserRequestId requestId;
    /**
     * Information about the current foreground Android user.
     */
    UserInfo userInfo;
    /**
     * Number of association being queried.
     */
    int32_t numberAssociationTypes;
    /**
     * Types of association being queried.
     */
    vec<UserIdentificationAssociationType> associationTypes;
};
/**
 * Defines the format of a set() call to USER_IDENTIFICATION_ASSOCIATION.
 *
 * NOTE: this struct is not used in the HAL properties directly, it must be converted to
 * VehiclePropValue.RawValue through libraries provided by the default Vehicle HAL implementation.
 */
struct UserIdentificationSetRequest {
    /**
     * Id of the request being responded.
     */
    UserRequestId requestId;
    /**
     * Information about the current foreground Android user.
     */
    UserInfo userInfo;
    /**
     * Number of association being set.
     */
    int32_t numberAssociations;
    /**
     * Associations being set.
     */
    vec<UserIdentificationSetAssociation> associations;
};
/**
 * Defines the result of a USER_IDENTIFICATION_ASSOCIATION - both for get() and set().
 *
 * NOTE: this struct is not used in the HAL properties directly, it must be converted to
 * VehiclePropValue.RawValue through libraries provided by the default Vehicle HAL implementation.
 */
struct UserIdentificationResponse {
    /**
     * Id of the request being responded.
     */
    UserRequestId requestId;
    /**
     * Number of associations being returned.
     */
    int32_t numberAssociation;
    /**
     * Values associated with the user.
     */
    vec<UserIdentificationAssociation> associations;
    /**
     * HAL-specific error message.
     *
     * This argument is optional, and when defined, it's passed "as-is" to the caller. It could be
     * used to show custom error messages to the end user.
     */
    string errorMessage;
};
/**
 * Helper struct used when getting a user/identification association type.
 */
struct UserIdentificationAssociation {
    UserIdentificationAssociationType type;
    UserIdentificationAssociationValue value;
};
/**
 * Helper struct used when setting a user/identification association type.
 */
struct UserIdentificationSetAssociation {
    UserIdentificationAssociationType type;
    UserIdentificationAssociationSetValue value;
};
/**
 * A rotary control which can rotate without limits. These controls use HW_ROTARY_INPUT to report
 * relative clockwise or counterclockwise motion. They have no absolute position.
 */
enum RotaryInputType : int32_t {
    /**
      * Main rotary control, typically in the center console, used to navigate the user interface.
      */
    ROTARY_INPUT_TYPE_SYSTEM_NAVIGATION = 0,
    /** Volume control for adjusting audio volume. */
    ROTARY_INPUT_TYPE_AUDIO_VOLUME = 1,
};
